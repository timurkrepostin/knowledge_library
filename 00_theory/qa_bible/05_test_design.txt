** Тест-дизайн и техники тест-дизайна (Test Design and Software Testing Techniques)

Проектирование теста (test design): Процесс перевода общих причин тестирования в
конкретные тестовые условия и тестовые сценарии. (ISTQB)
Причина тестирования (test objective): Причина или цель разработки и выполнения теста. (ISTQB)
Тестовое условие (test condition): Объект или событие в компоненте или системе, которое
должно быть проверено одним или несколькими тестовыми наборами. Например: функция,
транзакция, свойство, атрибут качества или структурный элемент. (ISTQB)

Тест-дизайн - важный этап STLС, а именно деятельность по получению и определению тестовых
примеров из test objectives и test conditions. Проще говоря, цель тест-дизайна -
создать максимально эффективный набор кейсов, покрывающий наиболее важные аспекты
тестируемого ПО, т.е. минимизировать количество тестов, необходимых для нахождения
большинства серьезных ошибок.

Полная спецификация не означает безошибочную спецификацию, так как во время разработки
теста можно найти и исправить множество проблем (предотвращение дефектов). Это только
означает, что у нас есть все необходимые требования или в Agile разработке у нас есть
все эпики, темы и пользовательские истории с критериями приемлемости (acceptance criteria).
Существует минимальная ценность в одновременном рассмотрении затрат на тестирование и
затрат на исправление дефектов, и цель хорошего тест-дизайна - выбрать подходящие методы
тестирования, приближающиеся к этому минимуму. Это можно сделать, проанализировав
сложность, риски и используя исторические данные. Таким образом, анализ рисков неизбежен
для определения тщательности тестирования. Чем выше риск использования функции / объекта,
тем более тщательное тестирование необходимо.

Итак, хороший процесс тест-дизайна выглядит так:
1. Сбор информации, чтобы понять требования пользователей;
2. Получение всех важных бизнес-сценариев;
3. Создание тестовых сценариев для каждого производного критически важного бизнес-сценария;
4. Назначение всех запланированных тестовых сценариев различным тестовым случаям;
Затем вам нужно будет выбрать технику тест-дизайна для каждого требования. На этом этапе,
если все реализовано правильно, вы можете внести значительные изменения, которые
чрезвычайно повлияют на ваш ROI.
задача тест аналитиков и дизайнеров сводится к тому, чтобы используя различные стратегии
и техники тест дизайна, создать набор Test case, обеспечивающий оптимальное тестовое
покрытие тестируемого приложения. 

Техники тест-дизайна (Software testing techniques)
1. Cтатические (Static):
● 1.1 Reviews:
1.1.1 Неформальное ревью (Informal review)
1.1.2 Прохождение (Walkthrough)
1.1.3 Техническое ревью (Technical Review)
1.1.4 Инспекция (Inspection)
● 1.2 Статический анализ (Static Analysis):
1.2.1 Поток данных (Data Flow)
1.2.2 Поток управления (Control Flow)
1.2.3 Путь (Path)
1.2.4 Стандарты (Standards)

2. Динамические (Dynamic):
● 2.1 Белый ящик (White-box, Structure-Based)
2.1.1 Выражение (Statement)
2.1.2 Решение (Decision)
2.1.3 Ветвь (Branch)
2.1.4 Условие (Condition)
2.1.5 Конечный автомат (FSM)
● 2.2 Основанные на опыте (Experience-based):
2.2.1 Предугадывание ошибки (Error Guessing - EG);
2.2.2 Исследовательское тестирование (Exploratory testing);
2.2.3 Ad-hoc testing;
2.2.4 Attack Testing;
● 2.3 Черный ящик (Black-box, Specification-based):
2.3.1 Эквивалентное Разделение (Equivalence Partitioning - EP)
2.3.2 Анализ Граничных Значений (Boundary Value Analysis - BVA)
2.3.3 Комбинаторные техники (Combinatorial Test Techniques)
2.3.4 Переходы между состояниями (State transition)
2.3.5 Случаи использования (Use case testing)
2.3.6 Domain testing
2.3.7 Decision Table Testing
2.3.8 Classification Tree Method
2.3.9 Cause-Effect Graphing
2.3.10 Scenario Testing
2.3.11 Random Testing
2.3.12 Syntax Testing
2.3.13 Check List Based Testing
2.3.14 Risk-Based Testing
2.3.15 User Journey Test

** Static - Reviews
● Рецензирование (review): Оценка состояния продукта или проекта с целью установления
расхождений с запланированными результатами и для выдвижения предложений по
совершенствованию. Примерами рецензирования могут служить: управленческое рецензирование,
неформальное рецензирование, технический анализ, инспекция и разбор. (ISTQB)
● Неформальное рецензирование (informal review): Рецензирование, которое не основано на
формальной (документированной) процедуре. (ISTQB)
● Разбор (walkthrough): Пошаговый разбор, проводимый автором документа для сбора
информации и обеспечения одинакового понимания содержания документа. (IEEE 1028)
● Равноправный анализ (peer review): Рецензирование разрабатываемого программного продукта,
проводящееся сотрудниками компании-разработчика с целью нахождения дефектов и внесение
улучшений. Примерами рецензирования являются: инспекция, технический анализ и разбор.
● Инспекция (inspection): Тип равноправного анализа, основанный на визуальной проверке
документов для поиска ошибок. Например, нарушение стандартов разработки и несоответствие
документации более высокого уровня. Наиболее формальная методика рецензирования и поэтому
всегда основывается на документированной процедуре. (IEEE 610, IEEE 1028).

● Экспертные обзоры (Peer Reviews): Рецензирование - это стандартизированный метод проверки
правильности исходного кода при разработке программного обеспечения, который проводится
для выявления дефектов на ранних этапах жизненного цикла и которые не могут быть
обнаружены с помощью методов тестирования черного ящика.
● Прохождение/просмотр/пошаговый разбор (walkthrough ): это метод проведения неформального
группового / индивидуального просмотра. В walkthrough автор описывает и объясняет рабочий
продукт на неформальной встрече своим коллегам или руководителю, чтобы получить обратную
связь. Здесь проверяется применимость предложенного решения для рабочего продукта.
Либо рабочий продукт проверяется на наличие дефектов несколькими лицами, кроме человека,
который его фактически произвел;
● Технический обзор (Technical Review): Это метод более высокого уровня по сравнению с
inspection или walkthrough, поскольку он также включает в себя управление. Этот метод
используется для оценки (assess and evaluate) продукта путем проверки его соответствия
стандартам разработки, руководствам и спецификациям. У него нет определенного процесса,
и большая часть работы выполняется модератором
● Инспекция: Инспекция определяется как наиболее формальная, тщательная, глубокая
групповая проверка, направленная на выявление проблем как можно ближе к их исходной точке.
Процесс проверки выполняется на ранних этапах SDLC и применяется к определенной части
продукта, такой как SRS, код, дизайн продукта. и т. д. Это включает в себя ручное
изучение различных компонентов продукта на более ранних этапах. 

** Static - Static Analysis
● Статический анализ (static analysis): Анализ артефактов разработки программного
обеспечения, таких как требования или программный код, проводимый без исполнения этих
программных артефактов. Статический анализ обычно выполняется при помощи вспомогательных
инструментов. (ISTQB)
● Статический анализ - это анализ программных артефактов, таких как программный код
(или требования, дизайн), выполняемый статически, т.е. без запуска и, очевидно, методом
белого ящика. Основная цель этого анализа - как можно раньше найти ошибки, независимо
от того, могут ли они вызывать отказы (failures). Как и в случае с обзорами (reviews),
статический анализ обнаруживает ошибки (bugs), а не отказы. Обычно статический анализ
проводят до формальной проверки, даже до unit testing, путём добавления этих проверок
специалистами DevOps в пайплайн проекта. 

Методы статического анализа:
● Анализ управления (Control Analysis): фокусируется на изучении элементов управления,
используемых в структуре вызовов, анализе потока управления и анализе переходов
состояний (calling structure, control flow analysis and state transition analysis).
Структура вызова связана с моделью путем идентификации вызовов и их структуры.
Вызывающая структура может быть процессом, подпрограммой, функцией или методом.
Анализ потока управления проверяет последовательность передачи управления и может выявить
неэффективные конструкции в модели. 
● Анализ данных (Data Analysis): обеспечивает правильную работу с объектами данных,
такими как структуры данных и связанные списки. Кроме того, этот метод также обеспечивает
правильное использование определенных данных. Анализ данных включает два метода,
а именно: зависимость данных и анализ потока данных (data dependency and data flow
analysis). Зависимость данных необходима для оценки точности синхронизации между
несколькими процессорами.
Анализ неисправностей / отказов (Fault/Failure Analysis): анализирует неисправности
(некорректный компонент) и отказ (некорректное поведение компонента модели) в модели.
Этот метод использует описание преобразования ввода-вывода для определения условий,
являющихся причиной сбоя.
Анализ интерфейса (Interface Analysis): проверяет взаимодействующие и распределенные
модели для проверки кода (This software verifies and verifies interactive and distribution
simulations to check the code). Существует два основных метода анализа интерфейса,
и анализ пользовательского интерфейса исследует интерфейсы подмоделей и определяет
точность структуры интерфейса.

** Dynamic - White box
● Разработка тестов методом белого ящика (white-box test design technique):
Процедура разработки или выбора тестовых сценариев на основании анализа внутренней
структуры компонента или системы. (ISTQB)
● Основанные на структуре методы проектирования тестирования используются для получения
контрольных примеров из структурной характеристики, например структуры исходного кода
или структуры меню. Если эти методы применяются к исходному коду приложения, то ожидаемые
результаты для контрольных примеров получаются из базиса тестирования. Выбор, какие из
основанных на структуре методов проектирования тестирования использовать в каждом
конкретном случае, зависит от природы базиса тестирования и от присущих рисков. (ГОСТ 56920)
● Поток данных (data flow): Абстрактное представление последовательности и возможных
изменений состояния объектов данных, при котором состояние объекта это: создание,
использование либо уничтожение. (Beizer)
● Поток управления (control flow): Последовательность событий (путей) в процессе выполнения
компонента или системы. (ISTQB)

Динамическое тестирование методом белого ящика - это стратегия, основанная на
внутренних путях, структуре и реализации тестируемого программного обеспечения.
Тесты здесь выполняются динамически, т.е. с запуском объекта тестирования и основаны
на различных видах покрытия кода (путей исполнения программы).
Глобально основных техник динамического тестирования методом белого ящика всего две:
1. Тестирование потока управления (Control Flow Testing);
2. Тестирование потока данных (Data Flow Testing).
Фактически, это динамическая часть одного цельного тестирования, статическая часть
которого - анализ и построение графа

Уровни тестового покрытия в тестировании потока управления
Под “покрытием" имеется в виду отношение объема кода, который уже был проверен, к объему,
который осталось проверить. В тестировании потока управления покрытие определяется в виде
нескольких различных уровней. Заметим, что эти уровни покрытия представлены не по порядку.
Это потому, что в некоторых случаях проще определить более высокий уровень покрытия,
а затем определить более низкий уровень покрытия в условиях высокого.
1. 100% покрытие операторов (Statement/node coverage). Оператор (statement) - это сущность
языка программирования, обычно являющаяся минимальным неделимым исполняемым блоком (ISTQB). 
2. 100% покрытие альтернатив/ветвей (Decision/branch/all-edges/basis path/DC/C2/
decision-decision-path/edge coverage). «Решение» - это программная точка, в которой
control flow имеет два или более альтернативных маршрута (ветви). На этом уровне
достаточно такого набора тестов, в котором каждый узел с ветвлением (альтернатива),
имеющий TRUE или FALSE на выходе, выполняется как минимум один раз, таким образом,
для покрытия по веткам требуется как минимум два тестовых примера.
3. 100% покрытие условий (Condition/Toggle Coverage). Рассматриваются только выражения
с логическими операндами, например, AND, OR, XOR. На этом уровне достаточно такого набора
тест-кейсов, в котором каждое условие, имеющее TRUE и FALSE на выходе, выполнено как
минимум один раз.
4. 100% покрытие условий + альтернатив (Decision + Condition coverage). На этом уровне
тест-кейсы создаются для каждого условия и для каждой альтернативы, т.е. данный метод
сочетает требования предыдущих двух методов - для обеспечения полного покрытия необходимо,
чтобы как логическое условие, так и каждая его компонента приняла все возможные значения;
5. 100% покрытия множественный условий (Multiple condition coverage). Для выявления
неверно заданных логических функций был предложен метод покрытия по всем условиям.

2. Тестирование потока данных (Data Flow Testing).
Тестирование потока данных - это еще один набор методов / стратегий белого ящика,
который связан с анализом потока управления, но с точки зрения жизненного цикла переменной.
Переменные определяются, используются и уничтожаются, когда в них больше нет необходимости.
Аномалии в этом процессе, такие как использование переменной без ее определения или после
ее уничтожения, могут привести к ошибке.

** Dynamic - Black box
Разработка тестов методом черного ящика (black box test design technique): Процедура
создания и/или выбора тестовых сценариев, основанная на анализе функциональной или
нефункциональной спецификации компонента или системы без знания внутренней структуры. (ISTQB)
Основанные на спецификации методы проектирования тестирования используются для получения
контрольных примеров из базиса тестирования, определяющего ожидаемое поведение элемента
тестирования. При использовании этих методов входные данные для тестирования контрольного
примера и ожидаемый результат получаются из базиса тестирования. Выбор, какие из
основанных на спецификации методов проектирования тестирования использовать в каждой
конкретной ситуации, зависит от природы базиса тестирования и/или элемента тестирования,
и от присущих рисков. (ГОСТ 56920)

● Эквивалентное разделение (Equivalence Partitioning (ISTQB/Myers 1979)
Класс эквивалентности представляет собой набор данных, которые либо одинаково обрабатываются модулем, либо их обработка выдает одинаковые результаты. При тестировании любое значение данных, входящее в класс эквивалентности, аналогично любому иному значению класса.
Эквивалентное разделение - это разделение всего набора данных ввода / вывода на такие разделы. Таким образом, вам не нужно выполнять тесты для каждого элемента подмножества, и достаточно одной проверки, чтобы охватить все подмножество. Хитрость заключается в том, чтобы увидеть и идентифицировать разделы, т.к. далеко не всегда они представляют собой числа.
Пример: Мы пишем модуль для системы отдела кадров, который определяет, в каком порядке нужно рассматривать заявления о приеме на работу в зависимости от возраста кандидата.
Правила нашей организации таковы:
от 0 до 16​ - не принимаются;
от 16 до 18​ - могут быть приняты только на неполный рабочий день;
от 18 до 55​ - могут быть приняты как сотрудники на полный рабочий день;
от 55 до 99​ - не принимаются;

Нужно ли нам делать проверку с такими входными значениями, как -42, FRED и &$#! @? Если
мы используем проектирование-по-контракту и тестирование-по-контракту, то ответ "Нет".
Если мы используем оборонительное проектирование и, поэтому, оборонительное тестирование,
то ответ "Да". Спросите ваших проектировщиков, какой подход они используют. Если их
ответом будет «контрактный» либо «оборонительный», то вы знаете, какой стиль тестирования
использовать. Если они ответят "Хм?", то это значит, что они не думают о том, как
взаимодействуют модули. Они не думают о предусловиях и постусловиях контрактов. Вам стоит
ожидать, что интеграционное тестирование будет главным источником дефектов, будет более
сложным и потребует больше времени, чем ожидалось.
Несмотря на то, что тестирование классов эквивалентности полезно, его величайшим вкладом
является то, что оно приводит нас к тестированию граничных значений.

● Анализ граничных значений (BVA - Boundary Value Analysis (Myers 1979)/range checking)
Тестирование классов эквивалентности - это самая основная методика тест-дизайна.
Она помогает тестировщикам выбрать небольшое подмножество из всех возможных тестовых
сценариев и при этом обеспечить приемлемое покрытие. У этой техники есть еще один плюс.
Она приводит к идее о тестировании граничных значений - второй ключевой технике
тест-дизайна.

Обратите внимание на проблемы на границах - это "края" каждого класса. Возраст "16"
входит в два различных класса эквивалентности (как и "18", и "55"). Первое правило гласит
не нанимать шестнадцатилетних. Второе правило гласит, что шестнадцатилетние могут быть
наняты на неполный рабочий день Тестирование граничных значений фокусируется на границах
именно потому, что там спрятано очень много дефектов.

Попробуем исправить приведенный выше пример:
от 0 до 15​ - не принимаются;
от 16 до 17​ - могут быть приняты только на неполный рабочий день;
от 18 до 54​ - могут быть приняты как сотрудники на полный рабочий день;
от 55 до 99​ - не принимаются;
А что насчет возраста -3 и 101? Обратите внимание, что требования не указывают, как
должны быть рассмотрены эти значения. Мы можем догадаться, но "угадывание требований"
не является приемлемой практикой.
В этом примере интересными значениями на границах или вблизи них являются {-1, 0, 1},
{15, 16, 17}, {17, 18, 19}, {54, 55, 56} и {98, 99, 100}. Другие значения, например
{-42, 1001, FRED, %$#@} могут быть включены в зависимости от предусловий документации
модуля.
Для создания тест-кейсов для каждого граничного значения определите классы эквивалентности,
выберите одну точку на границе, одну точку чуть ниже границы и одну точку чуть выше
границы. Стоит отметить, что точка чуть выше границы может входить в другой класс
эквивалентности. В таком случае не нужно дублировать тест. То же самое может быть верно
по отношению точки чуть ниже границы.

● Тестирование таблиц решений (Decision Table testing)
Этот простой, но эффективный метод заключается в документировании бизнес-логики в
таблице как наборы правил, условий выполнения действий и самих действий. Тестирование
таблиц принятия решений может быть использовано, когда система должна реализовывать
сложные бизнес-правила, когда эти правила могут быть представлены в виде комбинации
условий и когда эти условия имеют дискретные действия, связанные с ними.
Каждое правило является причиной "запуска" действия. Каждое правило может задать действие,
уникальное для этого правила, или правила могут иметь общие действия. Для каждого правила
с помощью таблицы решений можно указать более одного действия. Опять же, эти правила
могут быть уникальными или быть общими. В такой ситуации выбрать тесты просто - каждое
правило (вертикальная колонка) становится тест-кейсом. Условия указывают на входные
значения, а действия - на ожидаемые результаты.

● Комбинаторные техники тест-дизайна (Combination Strategies)
Комбинаторное тестирование (combinatorial testing): Метод, позволяющий выделить
подходящую подгруппу тестовых комбинаций с целью добиться предопределенного уровня
покрытия при тестировании объекта с множественными параметрами в случаях, когда эти
параметры сами по себе состоят из нескольких значений, что приводит к появлению большего
числа комбинаций, чем можно успеть протестировать за отведенное время. 
1. Все комбинации (All combinations): как видно из названия, этот алгоритм подразумевает
генерацию всех возможных комбинаций. Это означает исчерпывающее тестирование и имеет
смысл только при разумном количестве комбинаций. Например, 3 переменные с 3 значениями
для каждой дают нам матрицу параметров 3х3 с 27 возможными комбинациями.
2. Тестирование каждого выбора (EC - Each choice testing): эта стратегия требует, чтобы
каждое значение каждого параметра было включено по крайней мере в один тестовый пример
(Ammann & Offutt, 1994). Это также определение 1-wise coverage.
3. Тестирование базового выбора (BC - Base choice testing): алгоритм стратегии
комбинирования базового выбора начинается с определения одного базового тестового примера.
Базовый тестовый пример может быть определен по любому критерию, включая простейший,
наименьший или первый. Критерий, предложенный Амманном и Оффуттом (Ammann & Offutt, 1994),
- это «наиболее вероятное значение» с точки зрения конечного пользователя.

Попарное тестирование (Pairwise testing)
Pairwise testing - техника тест-дизайна, а именно метод обнаружения дефектов с
использованием комбинационного метода из двух тестовых случаев. Он основан на
наблюдениях о том, что большинство дефектов вызвано взаимодействием не более двух
факторов (дефекты, которые возникают при взаимодействии трех и более факторов, как
правило менее критичны). Следовательно, выбирается пара двух тестовых параметров,
и все возможные пары этих двух параметров отправляются в качестве входных параметров
для тестирования. Pairwise testing сокращает общее количество тест-кейсов, тем самым
уменьшая время и расходы, затраченные на тестирование. Захватывающей надеждой попарного
тестирования является то, что путем создания и запуска 1-20% тестов вы найдете 70-85% от
общего объема дефектов.

Пример: По ТЗ сайт должен работать в 8 браузерах, используя различные плагины,
запускаться на различных клиентских операционных системах, получать страницы от разных
веб-серверов, работать с различными серверными, операционными системами. Итого:
8 браузеров;
3 плагина;
6 клиентских операционных систем;
3 сервера;
3 серверных операционных системы;
= 1296 комбинаций. Количество комбинаций настолько велико, что, скорее всего, у нас не
хватит ресурсов, чтобы спроектировать и пройти тест-кейсы. Не следует пытаться проверить
все комбинации значений для всех переменных, а нужно проверять комбинации пар значений
переменных.

Использование всех пар для создания тест-кейсов основывается на двух техниках:
1. ортогональные массивы (OA - Orthogonal Array): это двумерный массив символов.
На примере выше мы составляем таблицу, где столбцы представляют собой переменные (браузер,
плагин, клиентская операционная система, веб-сервер и серверная операционная система,
а строки - значения каждой переменной (Chrome/Opera, Windows 8/10/11 и т.п.). После чего
нужно определить ортогональный массив, у которого будет столбец для каждой переменной
(каждый столбец ортогонального массива имеет столько же вариантов значений, сколько имеет
ваша переменная). Используя ортогональный массив для примера выше, все пары всех значений
всех переменных могут быть покрыты всего лишь 64-мя тестами.
2. алгоритм Allpairs​: генерирует пары непосредственно, не прибегая к таким к
ортогональным массивам. "Несбалансированный" характер алгоритма выбора всех пар требует
только 48 тестов для примера. Следует отметить, что комбинации, выбранные методом
ортогонального массива, могут быть не такими же, как те, которые выбраны Allpairs.
Но это не важно. Важно лишь то, чтобы были выбраны все парные комбинации параметров.
Это будут комбинации, которые мы хотим проверить.

Classification tree method
Метод дерева классификации (classification tree method): Разработка тестов методом
черного ящика, в которой тестовые сценарии, описанные средствами дерева классификации,
разрабатываются для проверки комбинаций выборок входных и/или выходных подмножеств.
(Grochtmann) См. также комбинаторное тестирование.
Дерево классификации (Classification tree): структура, показывающее иерархически
упорядоченные классы эквивалентности, которое используется для разработки тестовых
примеров в методе дерева классификации (Classification tree method).

Чтобы рассчитать количество тестовых примеров, нам необходимо проанализировать требования,
определить соответствующие тестовые функции (классификации) и их соответствующие значени
(классы).
Обычно для создания Classification tree используется инструмент Classification Tree Editor.
Если же взять лист бумаги и ручку, то у нас есть тестовый объект (целое приложение,
определенная функция, абстрактная идея и т. д.) вверху как корень. Мы рисуем ответвления
от корня как классификации (проверяем соответствующие аспекты, которые мы определили).
Затем, используя классы эквивалентности и анализ граничных значений, мы определяем наши
листья как классы из диапазона всех возможных значений для конкретной классификации.
И если некоторые из классов могут быть классифицированы далее, мы рисуем
под-ветку / классификацию с собственными листьями / классами. Когда наше дерево завершено,
мы делаем проекции листьев на горизонтальной линии (Test case), используя одну из
комбинаторных стратегий (all combinations, each choice и т. д.), и создаем все необходимые
комбинации.

** Тестирование переходов между состояниями (State Transition testing)
Таблица состояний (state table): Таблица, показывающая конечные переходы для каждого
состояния вследствие каждого возможного события, как для корректных, так и для
некорректных переходов. (ISTQB)
Тестирование переходов между состояниями определяется как метод тестирования ПО, при
котором изменения входных условий вызывают изменения состояния в тестируемом приложении
(AUT). В этом методе тестировщик предоставляет как положительные, так и негативные
входные значения теста и записывает поведение системы. Это модель, на которой основаны
система и тесты. Любая система, в которой вы получаете разные выходные данные для одного
и того же ввода, в зависимости от того, что произошло раньше, является системой конечных
состояний. Техника тестирования переходов между состояниями полезна, когда вам нужно
протестировать различные системные переходы. Этот подход лучше всего подходит там,
где есть возможность рассматривать всю систему как конечный автомат. 

1. Состояние (state, представленное в виде круга на диаграмме) - это состояние приложения,
в котором оно ожидает одно или более событий. Состояние помнит входные данные, полученные
до этого, и показывает, как приложение будет реагировать на полученные события.
События могут вызывать смену состояния и/или инициировать действия;
2. Переход (transition, представлено в виде стрелки на диаграмме) - это преобразование
одного состояния в другое, происходящее по событию;
3. Событие (event, представленное ярлыком над стрелкой) - это что-то, что заставляет
приложение поменять свое состояние. События могут поступать извне приложения, через
интерфейс самого приложения. Само приложение также может генерировать события (например,
событие «истек таймер»). Когда происходит событие, приложение может поменять
(или не поменять) состояние и выполнить (или не выполнить) действие. События могут иметь параметры (например, событие «Оплата» может иметь параметры «Наличные деньги», «Чек», «Приходная карта» или «Кредитная карта»);
4. Действие (action, представлено после «/» в ярлыке над переходом) инициируется сменой
состояния («напечатать билет», «показать на экране» и др.). Обычно действия создают
что-то, что является выходными/возвращаемыми данными системы. Действия возникают при
переходах, сами по себе состояния пассивны;

Определим четыре разных уровня покрытия:
1. Набор тестов, в котором все состояния​ будут посещены как минимум один раз. Этому
требованию удовлетворяет набор из трех тестов, показанный ниже. Обычно это низкий уровень
тестового покрытия.
2. Набор тестов, в котором все события​ выполнятся как минимум один раз. Следует отметить,
что тест-кейсы, которые покрывают каждое событие, могут быть точно теми же, которые
покрывают каждое состояние. Опять же, это низкий уровень покрытия.
3. Набор тестов, в котором все пути​ будут пройдены как минимум один раз. Несмотря на то,
что этот уровень является наиболее предпочтительным из-за его уровня покрытия, это может
быть неосуществимо. Если диаграмма состояний и переходов содержит петли, то количество
возможных путей может быть бесконечным.
4. Набор тестов, в котором все переходы​ будут осуществлены как минимум один раз. Этот
уровень тестирования обеспечивает хороший уровень покрытия без порождения большого
количества тестов. Этот уровень, как правило, один из рекомендованных.

Диаграмма состояний и переходов - не единственный способ документирования поведения
системы. Диаграммы, возможно, легче в понимании, но таблицы состояний и переходов могут
быть проще в использовании на постоянной и временной основе. Таблицы состояний и переходов
состоят из четырех столбцов - "Текущее состояние​", "Событие​", "Действие"​ и "Следующее
состояние"​. Преимущество таблицы состояний и переходов в том, что в ней перечисляются все
возможные комбинации состояний и переходов, а не только допустимые. При крайне необходимом
тестировании систем с высокой степенью риска, например авиационной радиоэлектротехники
или медицинских устройств, может потребоваться тестирование каждой пары состояние-переход,
включая те, которые не являются допустимыми. Кроме того, создание таблицы состояний и
переходов часто извлекает комбинации, которые не были определены, задокументированы или
рассмотрены в требованиях. 

** Domain testing
Анализ доменов (domain analysis): Методика разработки тестов, относящаяся к методу
черного ящика, использующаяся для определения действенных и эффективных тестовых
сценариев в случаях, когда множественные параметры могут или должны быть протестированы
одновременно. Методика базируется и обобщает методы эквивалентного разбиения и анализа
граничных значений/ (ISTQB)

В главах по тестированию классов эквивалентности и граничных значений мы рассмотрели
тестирование одиночных переменных, которые требовали оценки в указанных диапазонах.
В этой главе мы рассмотрим тестирование нескольких переменных одновременно. Существуют
две причины, по которым стоит обратить на это внимание:
1. у нас редко будет достаточно времени на создание тест-кейсов для каждой переменной
в нашей системе. Их просто слишком много;
2. часто переменные взаимодействуют. Значение одной переменной ограничивает допустимые
значения другой. В этом случае, если проверять переменные поодиночке, можно не
обнаружить некоторые дефекты;

Domain-тестирование​ - это техника, которая может применяться для определения эффективных
и действенных тест-кейсов, когда несколько переменных (например, поля ввода) должны
проверяться вместе - либо для эффективности, либо по причине их логического взаимодействия.
Она использует и обобщает тестирование классов эквивалентности и граничных значений в n
одномерных измерениях. Подобно этим техникам, мы ищем случаи, где граница была неверно
определена или реализована.

** Use case-based Testing
Сценарий использования системы (use case): Последовательность операций во взаимодействии
актера и компонента или системы со значимым результатом, при которой актером может быть
как пользователь, так и все, что может обмениваться информацией с системой. (ISTQB)
До сих пор мы исследовали техники разработки тестовых сценариев для частей системы -
входные переменные с их диапазонами и границами, бизнес-правила, представленные в виде
таблиц решений, а также поведения системы, представленные с помощью диаграмм состояний
и переходов. Теперь пришло время рассмотреть тестовые сценарии, которые используют
системные функции с начала и до конца путем тестирования каждой из их индивидуальных
операций.

Вариант использования (Use Case) - это сценарий, который описывает использование системы
действующим лицом для достижения определенной цели (Ивар Якобсон - "Объектно-ориентированная
разработка программ: подход, основанный на вариантах использования").

1. Действующее лицо (или актер) - это пользователь, играющий роль с уважением к системе,
старающегося использовать систему для достижения чего-то важного внутри конкретного
контекста. Действующими лицами в основном являются люди, хотя действующими лицами также
могут выступать другие системы;
2. "Сценарий" - это последовательность шагов, которые описывают взаимодействия между актером
и системой. Заметьте, что варианты использования определены с точки зрения пользователя,
а не системы. Заметьте также, что операции, выполняемые внутри системы, хоть и важны,
но не являются частью определения вариантов использования. Набор вариантов использования
составляет функциональные требования системы.

Cause/Effect, Cause-Effect (CE)
Таблица причинно-следственных решений (cause-effect decision table): См. таблица решений.
Таблица решений (decision table): Таблица, отражающая комбинации входных данных и/или
причин с соответствующими выходными данными и/или действиям (следствиям), которая может
быть использована для проектирования тестовых сценариев. (ISTQB)
Тестовые примеры должны быть разработаны так, чтобы проявлять принципы, которые
характеризуют взаимосвязь между входными и выходными данными компонента, где каждый
принцип соответствует единственной возможной комбинации входных данных компонента,
которые были выражены как логические значения. Для каждого тестового примера следует
уточнить:
Логическое состояние для каждого эффекта;
Логическое состояние (истина или ложь) по любой причине;

Граф причинно-следственных связей (Cause-Effect Graph) использует такую ​​модель логических
взаимосвязей между причинами и следствиями для компонента. Каждая причина выражается
как условие, которое может быть истинным, ложным на входе или комбинацией входных данных
компонента. Каждый эффект выражается в виде логического выражения, представляющего
результаты или комбинацию результатов для произошедшего компонента.

** Syntax testing
● Синтаксическое тестирование (syntax testing): Разработка тестов методом черного ящика,
в которой тестовые сценарии строятся на основе области определения входящих и/или
выходных значений. (ISTQB)
● Синтаксическое тестирование используется для проверки формата и правильности входных
данных в случаях символьных текстовых полей, проверки соответствия формату файла, схеме
базы данных, протоколу и т.д., при этом данные могут быть формально описаны в технических
или установленных и определенных обозначениях, таких как BNF

Синтаксис тестируется с использованием двух условий:
1. Валидные: Проверка нормального состояния с использованием покрывающего набора путей
синтаксического графа для минимально необходимых требований (?Testing the normal
condition using the covering set of paths of the syntax graph, for the minimum necessary
requirements). Иными словами находим возможные варианты значений, допускаемые отдельными
элементами определения BNF, а затем разрабатываем кейсы, чтобы просто охватить эти
варианты;
2. Невалидные: Проверка мусорных условий (garbage condition)* с использованием недопустимого
набора входных данных.
Примечание *: Мусорные условия - это метод проверки устойчивости системы к неверным или
грязным данным. Условие выполняется путем предоставления в систему грязных данных
(недопустимых данных), которые не поддерживаются указанным форматом и грамматикой
синтаксиса. Для создания таких данных мы определяем и применяем возможные мутации
(например, отсутствующий элемент, нежелательный дополнительный элемент, недопустимое
значение для элемента и т. д.) к отдельным элементам определения BNF.

** Check List Based Testing
Тестирование на основе контрольного списка (чеклиста) выполняется с использованием
предварительно подготовленного опытными тестировщиками чеклиста, который продолжает
обновляться с учетом любых новых дефектов, обнаруженных при выполнении контрольных
примеров контрольного списка. При любых изменениях в продукте прогоняется быстрый чеклист,
чтобы убедиться, что из-за изменений не возникло новых дефектов. Этот контрольный список
не имеет отношения к пользовательским историям.

** User Story Testing (Agile)
Пользовательская история - это краткое и простое описание требований клиентов или
конечного пользователя. Пользовательские истории написаны владельцем продукта
(Product owner), поскольку именно он получает от клиента информацию о продукте, который
будет создан. Если пользовательская история большая, она разбивается на несколько более
мелких историй. Истории пользователей записываются на учетных карточках и вывешиваются
на стене для обсуждения. Обсуждая важные аспекты функции, выберите те, которые
в дальнейшем используются в пользовательской истории. Приемочные испытания - это
заключительный этап, на котором продукт принимает заказчик после того, как он
соответствует всем критериям выхода. Критерии приемлемости определяются владельцем
продукта, заказчик на поставку также может привлекать разработчиков, определяя то же самое.

** Exhaustive testing
Исчерпывающее тестирование (exhaustive testing): Методика тестирования, в которой набор
тестов включает в себя все комбинации входных данных и предусловий. (ISTQB)
Исчерпывающее тестирование (Exhaustive testing - ET) - это крайний случай. В пределах
этой техники вы должны проверить все возможные комбинации входных значений, и в принципе,
это должно найти все проблемы. На практике применение этого метода почти всегда не
представляется возможным, из-за огромного количества входных значений.
