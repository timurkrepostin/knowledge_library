** QA/QC/Testing

● Обеспечение Качества - это совокупность запланированных и систематических процессов и
действий поддержки, необходимых для обеспечения надлежащего уровня уверенности в том,
что процесс или рабочий продукт удовлетворяет установленным техническим требованиям или
требованиям к качеству. Достигается это сочетанием методов, стандартов, инструментов
и навыков, признанных как соответствующая практика. Процесс Обеспечения Качества
использует результаты тестирования и другую информацию для анализа, оценки и
информирования о любой проблеме (включая любой риск) в проектировании, планировании
или выполнении процессов программной инженерии.
● Контроль качества (quality control): Рабочие методы и активности, нацеленные на
выполнение требований к качеству, являющиеся частью управления качеством. (ISO 8402)
● Тестирование (testing): Процесс, содержащий в себе все активности жизненного цикла,
как динамические, так и статические, касающиеся планирования, подготовки и оценки
программного продукта и связанных с этим результатов работ с целью определить, что они
соответствуют описанным требованиям, показать, что они подходят для заявленных целей
и для определения дефектов. (ISTQB)
● Обеспечение качества (QA - Quality Assurance) - это часть Quality Management
- совокупность мероприятий, охватывающих все технологические этапы разработки, выпуска
и поддержки ПО, предпринимаемых на разных стадиях жизненного цикла ПО, для обеспечения
требуемого уровня качества выпускаемого продукта. QA обеспечивает создание правильных
процессов для получения в результате качественного продукта.
● Это также означает создание процессов контроля качества (QC - Quality Control), которые
в свою очередь гарантируют, что процессы, установленные QA, соблюдаются. То есть QC -
это часть QA - процесс установления стандартов и проверки, что ПО сделано правильно.
Цель контроля качества - проверить, соблюдалась ли предписанная модель.

Активности QA проходят на всем протяжении SDLC: на этапе построения, анализа и улучшения
процессов, формирования релизных политик, риск менеджмента и прочих how-to’s.
QC подключаются на этапе составления критериев качества, quality gate-ов, метрик и
способов оценки.
Тестировщик вступает уже после этапа разработки (с shift left на этапе получения тз
и превращения его в спецификацию).
Иными словами, QA занимается не проверкой постфактум уже готового ПО на соответствие
требованиям и наличие дефектов, а пытается предотвратить само появление этих дефектов,
являясь эдаким “инфлюенсером”, специалистом, влияющим на процессы разработки и
улучшающий их качество для обеспечения качества итогового продукта.
Основными целями тестирования как части QC являются:
1. предоставление информации о качестве элемента тестирования и любых остаточных рисках
относительно того, до какой степени элемент тестирования был проверен;
2. обнаружение дефектов в элементе тестирования до его передачи в эксплуатацию;
3. смягчение рисков получения продукта низкого качества заинтересованными сторонами.
Вышеупомянутая информация может использоваться в нескольких целях, включая:
1. улучшение элемента тестирования путем устранения дефектов;
2. улучшение управленческих решений, предоставляя как основание для решений информацию
о качестве и рисках;
3. улучшение процессов в организации, особо выделяя процессы, которые позволяют дефектам
возникать и/или оставаться скрытыми там, где они могут быть обнаружены.

** Почему требуется тестирование ПО?
Необходимость тестирования программного обеспечения может быть продиктована следующими
условиями:
1. лица, принимающие решения, запрашивают информацию о показателях качества элемента(ов)
тестирования;
2. проверяемый(ые) элемент(ы) тестирования не всегда делает то, что от него (них)
ожидается;
3. необходимо произвести верификацию проверяемого(ых) элемента(ов) тестирования;
4. необходимо произвести валидацию проверяемого(ых) элемента(ов) тестирования и/или
5. необходимо провести оценку элемента(ов) тестирования по всему жизненному циклу
разработки программного обеспечения и систем.

Общеизвестно, что создать совершенное программное обеспечение невозможно. Поэтому прежде
чем программное обеспечение будет передано пользователям, его необходимо протестировать,
чтобы в производстве программного обеспечения снизить риск ошибок, оказывающих негативное
влияние на его функционирование. В равной степени необходимо обеспечить качественное
выполнение тестирования программного обеспечения.

** Качество ПО (Software Quality)
● Качество программного обеспечения (software quality): Сумма функциональности и
технических характеристик программного продукта, отвечающих за возможность выполнения
сформулированных или подразумевающихся задач. (ISO 9126)
Качество (quality): Степень, с которой компонент, система или процесс соответствует
зафиксированным требованиям и/или ожиданиям и нуждам пользователя или заказчика. (IEEE 610)
Формально стандарт ISO 8402-1986 определяет качество как совокупность функций и
характеристик продукта или сервиса, которые обладают способностью удовлетворять явные
или неявные требования. Иными словами, качество заключается в соответствии требованиям
(conformance to requirements) и пригодности к использованию (fitness for use),
т.е. характеризуется набором свойств, определяющих, насколько продукт "хорош" с точки
зрения заинтересованных сторон, например, заказчик продукта или пользователь.

● Показатели качества:
1. функциональная пригодность: степень, с которой продукт или система обеспечивают
выполнение функции в соответствии с заявленными и подразумеваемыми потребностями
при использовании при указанных условиях;
2. уровень производительности: производительность относительно суммы использованных
при определенных условиях ресурсов;
3. совместимость: способность продукта, системы или компонента обмениваться информацией
с другими продуктами, системами или компонентами и/или выполнять требуемые функции
при совместном использовании одних и тех же аппаратных средств или программной среды;
4. удобство использования: степень, с которой продукт или система могут быть использованы
определенными пользователями для достижения конкретных целей с эффективностью,
результативностью и удовлетворенностью в заданном контексте использования;
5. надежность: степень выполнения системой, продуктом или компонентом определенных функций
при указанных условиях в течение установленного периода времени;
6. защищенность: степень защищенности информации и данных, обеспечиваемая продуктом или
системой путем ограничения доступа людей, других продуктов или систем к данным в
соответствии с типами и уровнями авторизации;
7. сопровождаемость: результативность и эффективность, с которыми продукт или система
могут быть модифицированы предполагаемыми специалистами по обслуживанию;
8. переносимость: степень простоты эффективного и рационального переноса системы,
продукта или компонента из одной среды (аппаратных средств, программного обеспечения,
операционных условий или условий использования) в другую.

** Принципы тестирования
1. Тестирование демонстрирует наличие дефектов (Testing shows presence of defects)
2. Исчерпывающее тестирование недостижимо (Exhaustive testing is not possible)
3. Раннее тестирование (Early testing)
4. Скопление/кластеризация дефектов (Defect clustering)
5. Парадокс пестицида (Pesticide paradox)
6. Тестирование зависит от контекста (Testing is context dependent)
7. Заблуждение об отсутствии ошибок (Absence of errors fallacy)

Принцип 1. Тестирование показывает наличие дефектов
Тестирование может показать, что дефекты присутствуют, но не может доказать, что
дефектов больше нет.
Сколько бы успешных тестов вы не провели, вы не можете утверждать, что нет таких тестов,
которые не нашли бы ошибку.

Принцип 2. Исчерпывающее тестирование невозможно
Для проведения исчерпывающего тестирования придется протестировать все возможные входные
значения и все пути выполнения программы, в большинстве случаев число таких вариаций
стремится к бесконечности или просто на порядки превосходит отведенное время и бюджет.
Вместо попыток «протестировать все» нам нужен некий подход к тестированию (стратегия),
который обеспечит правильный объем тестирования для данного проекта, данных заказчиков
(и других заинтересованных лиц) и данного продукта.

Принцип 3. Раннее тестирование
Тестовые активности должны начинаться как можно раньше в SDLC, а именно когда
сформированы требования.
Этот принцип связан с понятием «цена дефекта» (cost of defect). Цена дефекта существенно
растет на протяжении жизненного цикла разработки ПО. Чем раньше обнаружен дефект, тем
быстрее, проще и дешевле его исправить. Дефект, найденный в требованиях, обходится дешевле
всего. Еще одно важное преимущество раннего тестирования - экономия времени.

Принцип 4. Скопление дефектов
Небольшое количество модулей содержит большинство дефектов, обнаруженных на этапе
предрелизного тестирования, или же демонстрируют наибольшее количество отказов на этапе
эксплуатации.
Многие тестировщики наблюдали такой эффект - дефекты «кучкуются». Это может происходить
потому, что определенная область кода особенно сложна и запутана, или потому, что
внесение изменений производит «эффект домино». Это знание часто используется для оценки
рисков при планировании тестов - тестировщики фокусируются на известных «проблемных зонах». 

Принцип 5. Парадокс пестицида
Boris Beizer в своей книге Software Testing Techniques объяснил парадокс пестицида как
феномен, согласно которому чем больше вы тестируете ПО, тем более невосприимчивым оно
становится к имеющимся тестам, т.е. каждый метод и набор тестов, который используется
для предотвращения или поиска ошибок, может оставлять часть не найденных ошибок, против
которых эти методы и тесты неэффективны;
имеющиеся тесты устаревают после исправления дефекта и не могут обнаружить новые;
Из чего следует, что набор тестов, тестовых данных и подходов нужно постоянно
пересматривать и улучшать для выявления не найденных ошибок, а также необходимо обновлять
тесты и тестовые данные после исправления уже найденных дефектов.

Принцип 6. Тестирование зависит от контекста
Тестирование выполняется по-разному, в зависимости от контекста. Например, тестирование
систем, критических с точки зрения безопасности, проводится иначе, чем тестирование
сайта интернет-магазина.
Этот принцип тесно связан с понятием риска. Что такое риск? Риск - это потенциальная
проблема. У риска есть вероятность (likelihood) - она всегда выше 0 и ниже 100% - и есть
влияние (impact) - те негативные последствия, которых мы опасаемся. Анализируя риски,
мы всегда взвешиваем эти два аспекта: вероятность и влияние.

Принцип 7. Заблуждение об отсутствии ошибок
Нахождение и исправление дефектов бесполезно, если построенная система неудобна для
использования и не соответствует нуждам и ожиданиям пользователей.
Пользователи ПО более заинтересованы в том, чтобы оно помогало им эффективно выполнять
задачи. ПО должно отвечать их потребностям, и именно с этой точки зрения они его оценивают.
Даже если вы выполнили все тесты и ошибок не обнаружили, это еще не гарантия того, что
ПО будет соответствовать нуждам и ожиданиям пользователей. Верификация не равна валидации.

** Верификация и валидация (Verification and Validation)

● Верификация (verification): Доказанное объективными результатами исследования
подтверждение того, что определенные требования были выполнены. (ISO 9000)
● Валидация (validation): Доказанное объективными результатами исследования подтверждение
того, что требования для ожидаемого конкретного использования приложения были
выполнены. (ISO 9000)
● Верификация - это подтверждение путем представления объективных доказательств выполнения
данным рабочим элементом установленных требований. (ГОСТ 56920)
● Валидация демонстрирует, что рабочий элемент может использоваться пользователями для
решения определенных ими задач. (ГОСТ 56920)

Верификация - это проверки, выполняемые в процессе разработки ПО для ответа на вопрос:
“правильно ли мы разрабатываем продукт?”.
Верификация гарантирует, что ПО разрабатывается в соответствии со стандартами и
процессами организации, полагаясь на reviews и статические методы тестирования.
Валидация - это процесс оценки конечного продукта, чтобы проверить, соответствует ли он
потребностям бизнеса и ожиданиям клиентов, т.е. отвечает на вопрос: “правильный ли мы
разработали продукт?”. Валидация является динамическим тестированием, т.е. происходит
с помощью выполнения кода и прогона тестов на нём (UAT/CAT, usability, всё что угодно).
Валидация является реактивным подходом (Reactive approach).

Если попробовать привести очень упрощенный пример, представим блюдо в ресторане.
Верификация будет включать проверку технологической карты, оценку процесса приготовления
(температуры, времени и т.п.). На протяжении этого процесса можно будет примерно быть
уверенным, что блюдо получится именно тем, какое задумывалось и в итоге формально мы его
приготовим. Валидация же - это, по сути, попробовать приготовленное блюдо, чтобы
удостовериться, действительно ли получилось то, что ожидал бизнес и клиент.

** Дефекты и ошибки 
Прежде всего, стоит разобраться с терминологией. В определениях
Error/Mistake/Defect/Bug/Failure/Fault три из них переводятся на русский язык как ошибка.
Определения из ISTQB:
Просчет (mistake): См. ошибка;
Помеха (bug): См. дефект;
Недочет (fault): См. дефект;
Ошибка (error): Действие человека, которое приводит к неправильному результату;
Дефект (defect): Изъян в компоненте или системе, который может привести компонент или
систему к невозможности выполнить требуемую функцию, например неверный оператор или
определение данных. Дефект, обнаруженный во время выполнения, может привести к
отказам компонента или системы;
Отказ (failure): Отклонение компонента или системы от ожидаемого выполнения, эксплуатации
или результата.
Неофициальные же источники показывают более широкую картину:
Ошибка (Error) возникает из-за просчета (Mistake) в написании кода разработчиком;
Дефект (Defect) это скрытый недостаток в ПО, возникший из-за ошибки в написании кода;
Когда дефект (Defect) обнаруживается тестировщиком, он называется багом (Bug);
Если тестировщики упустили дефект и его нашел пользователь, то это сбой (Failure);
Если программа в итоге не выполняет свою функцию, то это отказ (Fault).

Классы дефектов:
● Дефекты требований и спецификаций (Requirements and Specifications Defects): Начало
жизненного цикла программного обеспечения важно для обеспечения высокого качества
разрабатываемого программного обеспечения. Дефекты, введенные на ранних этапах, очень
трудно устранить на более поздних этапах.
● Дефекты дизайна: Дефекты дизайна возникают когда неправильно спроектированы:
Системные компоненты, Взаимодействие между компонентами системы, Взаимодействие между
компонентами и внешним программным / аппаратным обеспечением или пользователями. Они
включают дефекты в конструкции алгоритмов, управления, логики, элементов данных,
описаний интерфейсов модулей и описаний внешнего программного обеспечения / оборудования
/ пользовательского интерфейса.
● Дефекты кода: Дефекты кодирования возникают из-за ошибок при реализации кода.
Классы дефектов кодирования аналогичны классам дефектов дизайна. Некоторые дефекты
кодирования возникают из-за непонимания конструкций языка программирования и недопонимания
с разработчиками.
● Дефекты тестирования: Планы тестирования, тестовые наборы, средства тестирования и
процедуры тестирования также могут содержать дефекты. Эти дефекты называются дефектами
тестирования. Дефекты в планах тестирования лучше всего обнаруживать с помощью методов
review.
Жизненный цикл дефекта (Defect/Bug Life Cycle)
Жизненный цикл дефекта - это представление различных состояний дефекта, в которых он
пребывает от начального до конечного этапа своего существования. Он может варьироваться
от компании к компании и настраиваться под процессы конкретного проекта.
● Новый (New): когда новый дефект регистрируется и публикуется впервые;
● Назначен (Assigned): после публикации бага тестировщиком руководитель тестировщика
утверждает ошибку и передает ее команде разработчиков;
● Открыт (Open): разработчик начинает анализ и работает над исправлением бага;
● Исправлен (Fixed): разработчик внес необходимое изменение в код и проверил его;
● Ожидает повторного тестирования (Pending retest): как только дефект будет исправлен,
разработчик предоставляет тестировщику конкретный код для повторного тестирования кода.
Поскольку тестирование программного обеспечения остается незавершенным со стороны
тестировщиков, ему присваивается статус «ожидает повторного тестирования»;
● Повторное тестирование (Retest): на этом этапе тестировщик выполняет повторное
тестирование кода, чтобы проверить, исправлен ли дефект разработчиком;
● Проверен (Verified): тестировщик повторно тестирует баг после его исправления
разработчиком. Если баг исправлен, то присваивается статус «проверено»;
● Переоткрыт (Reopen): если баг сохраняется даже после того, как разработчик исправил
баг, тестировщик меняет статус на «повторно открыт». И снова баг проходит жизненный цикл.
● Закрыт (Closed): если баг больше не существует, тестировщик присваивает статус
«Закрыто».
● Дубль (Duplicate): если дефект повторяется дважды или дефект соответствует той же
концепции ошибки, статус изменяется на «дублировать».
● Отклонен (Rejected): если разработчик считает, что дефект не является таковым, он
меняет статус на «отклонен»;
● Отложен (Deferred): если текущий баг не является приоритетным и ожидается, что он
будет исправлен в следующем выпуске, таким багам присваивается статус «Отложено»;
● Не является багом (Not a bug): если это не влияет на функциональность приложения,
то багу присваивается статус «Не является багом».

** Серьезность и приоритет Дефекта (Severity & Priority)
Bug management включает в себя процесс документирования, категоризации, назначения,
воспроизведения, исправления и выпуска исправленного кода. Предлагаемые изменения в
программном обеспечении - баги, запросы на улучшения и даже целые релизы - обычно
отслеживаются и управляются с помощью баг-трекинговых систем. Добавленные элементы могут
называться дефектами, заявками, проблемами или, в соответствии с парадигмой гибкой
разработки, эпиками и сторями (stories and epics). Категории могут быть объективными,
субъективными или комбинированными, такими как номер версии, область программного
обеспечения, серьезность и приоритет, а также тип проблемы, такой как фича-реквест или баг.

Критичность (severity): Важность воздействия конкретного дефекта на разработку или
функционирование компонента или системы. (IEEE 610)
Приоритет (priority): Степень важности, присваиваемая объекту. Например, дефекту. (ISTQB)

Градация Серьезности (Severity):
● Критическая (critical) - существование дефекта приводит к масштабным последствиям
катастрофического характера, например: потеря данных, раскрытие конфиденциальной
информации, нарушение ключевой функциональности приложения и т.д.;
● Высокая (major) - существование дефекта приносит ощутимые неудобства многим
пользователям в рамках их типичной деятельности, например: недоступность вставки
из буфера обмена, неработоспособность общепринятых клавиатурных комбинаций, необходимость
перезапуска приложения при выполнении типичных сценариев работы;
● Средняя (medium) - существование дефекта слабо влияет на типичные сценарии работы
пользователей, и/или существует обходной путь достижения цели, например: диалоговое окно
не закрывается автоматически после нажатия кнопок «OK»/«Cancel», при распечатке
нескольких документов подряд не сохраняется значение поля «Двусторонняя печать»,
перепутаны направления сортировок по некоему полю таблицы;
● Низкая (minor) - существование дефекта редко обнаруживается незначительным процентом
пользователей и (почти) не влияет на их работу, например: опечатка в глубоко вложенном
пункте меню настроек, некое окно сразу при отображении расположено неудобно
(нужно перетянуть его в удобное место), неточно отображается время до завершения
операции копирования файлов.

Градация Срочности/приоритета (Priority):
● Наивысшая (ASAP, as soon as possible) срочность указывает на необходимость устранить
дефект настолько быстро, насколько это возможно. В зависимости от контекста «настолько
быстро, насколько возможно» может варьироваться от «в ближайшем билде» до единиц минут;
● Высокая (high) срочность означает, что дефект следует исправить вне очереди, т.к. его
существование или уже объективно мешает работе, или начнёт создавать такие помехи в самом
ближайшем будущем;
● Обычная (normal) срочность означает, что дефект следует исправить в порядке общей
очередности. Такое значение срочности получает большинство дефектов;
● Низкая (low) срочность означает, что в обозримом будущем исправление данного дефекта
не окажет существенного влияния на повышение качества продукта.
