** Жизненный цикл разработки ПО (SDLC - Software Development Lifecycle)
● Жизненный цикл программного обеспечения (software lifecycle): Период времени,
начинающийся с момента появления концепции программного обеспечения и заканчивающийся
тогда, когда дальнейшее использование программного обеспечения невозможно. Жизненный цикл
программного обеспечения обычно включает в себя следующие этапы: концепт, описание
требований, дизайн, реализация, тестирование, инсталляция и наладка, эксплуатация
и поддержка и, иногда, этап вывода из эксплуатации. Данные фазы могут накладываться друг
на друга или проводиться итерационно. (ISTQB)
● Период времени от концепции до первоначальной версии известен как жизненный цикл
разработки, который является частью жизненного цикла программного обеспечения. С момента
первого запуска система переходит в эксплуатацию (функционирование). Система остается
в эксплуатации до момента прекращения использования. (ГОСТ 56920)
● SDLC - это систематизированный процесс, этапы которого охватывают полный жизненный цикл
программного обеспечения (Software Lifecycle) и который определяет различные этапы
разработки программного обеспечения для создания высококачественного программного
обеспечения, отвечающего ожиданиям клиентов и для улучшения эффективности разработки.
Разработка системы должна быть завершена в заранее определенные сроки и стоимость.
Каждая фаза жизненного цикла SDLC имеет свой собственный процесс и результаты, которые
используются в следующей фазе.

Фазы SDLC:
● Сбор и анализ требований (Requirement Gathering and Analysis): На этом этапе от клиента
собирается вся необходимая информация для разработки продукта в соответствии с их
ожиданиями. Любые неясности должны быть разрешены сразу на этом этапе. Бизнес-аналитик
и менеджер проекта назначили встречу с заказчиком, чтобы собрать всю информацию, например,
что заказчик хочет построить, кто будет конечным пользователем, какова цель продукта.
Перед созданием продукта очень важно понимание или знание продукта. Например, клиент
хочет иметь приложение, которое включает денежные транзакции. В этом случае требование
должно быть четким, например, какие транзакции будут выполняться, как они будут
проводиться, в какой валюте они будут проводиться и т. д. После того, как сбор требований
завершен, проводится анализ для проверки возможности разработки продукта. После четкого
понимания требования создается документ SRS (Спецификация требований к программному
обеспечению). Этот документ должен быть полностью понят разработчикам, а также должен быть
рассмотрен заказчиком для использования в будущем;

● Дизайн (Design): На этом этапе требования, собранные в документе SRS, используются
в качестве входных данных, и создается архитектура программного обеспечения, которая
используется для реализации разработки системы. Создаются два вида дизайн-документов:
1. Высокоуровневый дизайн (HLD - High-Level Design):
Краткое описание и название каждого модуля;
Краткое описание функциональности каждого модуля;
Отношения интерфейсов и зависимости между модулями;
Таблицы базы данных, идентифицированные вместе с их ключевыми элементами;
Полные архитектурные схемы с подробными сведениями о технологиях.
2. Низкоуровневый дизайн (LLD - Low-Level Design):
Функциональная логика модулей;
Таблицы базы данных, которые включают тип и размер;
Полная детализация интерфейсов;
Решение всех типов проблем с зависимостями;
Список сообщений об ошибках;
Полные входные и выходные значения для каждого модуля.

● Разработка (Implementation or Coding): Реализация / кодирование начинается, как только
разработчик получает Design document. Дизайн программного обеспечения переведен в исходный
код. На этом этапе реализуются все компоненты программного обеспечения;

● Тестирование (Testing): Тестирование начинается после завершения кодирования и выпуска
модулей для тестирования. На этом этапе разработанное программное обеспечение тщательно
тестируется, и все обнаруженные дефекты передаются разработчикам для их исправления.
Повторное тестирование, регрессионное тестирование проводится до тех пор, пока программное
обеспечение не будет соответствовать ожиданиям клиента. Тестировщики обращаются к
документу SRS, чтобы убедиться, что программное обеспечение соответствует стандарту
заказчика;

● Развертывание (Deployment): После тестирования продукта он развертывается в
производственной среде или выполняется первое UAT (пользовательское приемочное
тестирование), в зависимости от ожиданий клиента. В случае UAT создается копия
производственной среды, и заказчик вместе с разработчиками выполняет тестирование.
Если клиент остается доволен, то предоставляет согласие на релиз;

● Поддержка (Maintenance): Основное внимание на этом этапе SDLC уделяется обеспечению того,
чтобы потребности продолжали удовлетворяться и чтобы система продолжала работать в
соответствии со спецификацией, упомянутой в первом этапе. После того, как система
развернута и клиенты начинают использовать разработанную систему следует 3 вида
активностей:
Исправление ошибок;
Обновление;
Улучшение.

** Жизненный цикл тестирования ПО (STLC - Software Testing Lifecycle)
● STLC - это процесс тестирования, который включает в себя определенную последовательность
шагов, чтобы гарантировать достижение целей в области качества. В процессе STLC каждое
действие выполняется планомерно и систематически. Каждый этап имеет разные цели и
результаты. У разных организаций разные этапы STLC, однако основа остается прежней.
Каждая фаза STLC имеет критерии начала и окончания:
1. Критерии входа (entry criteria): Набор общих и специфичных условий для продолжения
процесса с определенной задачей, например, фаза тестирования. Цель критериев входа -
предотвращение начала задачи, которое может потребовать больше (бесполезных) усилий,
чем на устранение не пройденных критериев входа. (Gilb and Graham)
2. Критерии выхода (exit criteria): Набор общих и специфичных условий, согласованных
заранее с заинтересованными сторонами, для того, чтобы процесс мог официально считаться
завершенным. Цель критериев выхода - предотвращение возможности, когда задание считается
завершенным, однако еще существуют отдельные незавершенные части задания. Критерии выхода
используются для отчетности, а также планирования того, когда остановить тестирование. (Gilb and Graham)

STLC имеет несколько взаимосвязанных фаз и в целом очень похож на SDLC. Эти фазы являются
последовательными и называются:
● Анализ требований (Requirement Analysis): один из важнейших этапов, потому что именно
на нем можно почти бесплатно исправить недостатки проекта. Этап анализа требований также
определяет потенциальную потребность в автоматизированном тестировании и позволяет
производить экономические расчеты затрат на рабочую силу на основе оценки проекта.
На этом же этапе обсуждаются и документируются критерии начала и окончания тестирования.
1. Entry Criteria: BRS (Business Requirement Specification)
2. Deliverables: список всех проверяемых требований, технико-экономическое обоснование
автоматизации (если применимо);
● Планирование тестирования (Test Planning): на этом этапе формируется план тестирования,
т.е. мы определяем действия и ресурсы, которые помогут достичь целей тестирования
(участники и их роли, инструменты, окружение). Во время планирования мы также пытаемся
определить метрики, метод сбора и отслеживания этих метрик. План составляют исходя из
требований, тестовой стратегии и анализа рисков.
1. Entry Criteria: Requirements Documents;
2. Deliverables: Test Strategy, Test Plan, and Test Effort estimation document.
● Разработка тест-кейсов (Test Case Development): подразумевает использование ручного
и автоматизированного тестирования для достижения полного охвата функциональности
программного обеспечения, при этом процесс основан на заранее установленных требованиях.
Чаще всего тест-кейсы для автоматического тестирования пишутся отдельно, так как кейсы
для ручного тестирования описаны в виде шпаргалок (cheat sheets).
1. Entry Criteria: Requirements Documents (Updated version);
2. Deliverables: Test cases, Test Scripts (if automation), Test data.
● Настройка тестовой среды (Test Environment Setup): в плане тестирования четко указано,
какую тестовую среду следует использовать. На этом этапе STLC настраиваются операционные
системы и виртуальные машины, развертываются инструменты тестирования, такие как
Selenium, Katalon Studio, а также тестовая среда и базы данных проекта. Мы также
обращаемся с запросами к DevOps и администраторам, если требуется поддержка.
1. Entry Criteria: Test Plan, Smoke Test cases, Test Data;
2. Deliverables: Test Environment. Smoke Test Results.
● Выполнение тестов (Test Execution): тесты выполняются на основе готовой тестовой
документации и правильно настроенной тестовой среды. Все результаты тестирования
регистрируются в Системе управления тестированием. Отрицательно пройденные тесты,
в которых фактический результат отличается от ожидаемого, регистрируются как ошибки
и передаются команде разработчиков на доработку с последующей перепроверкой после
исправления.
1. Entry Criteria: Test Plan document, Test cases, Test data, Test Environment;
2. Deliverables: Test case execution report, Defect report, RTM.
● Завершение цикла испытаний (Test Cycle Closure): окончательная генерация отчетов
о тестировании для клиента. Они должны включать затраченное время, процент обнаруженных
ошибок и положительных результатов тестирования, общее количество обнаруженных
и исправленных ошибок. Что касается отдела тестирования, то это момент для анализа
его работы, подведения итогов, анализа его продуктивности и возможности внести предложения
по улучшению качества тестирования.
1. Entry Criteria: Test Case Execution report (убедитесь, что нет открытых high severity
defects), Defect report;
2. Deliverables: Test Closure report, Test metrics.

● Разница STLC и SDLC
STLC и SDLC тесно связаны друг с другом, но они одновременно преследуют разные задачи
с одной и той же целью, а именно:
1. сбор требований в желаемой форме и разработка заявленной функциональности (SDLC);
2. анализ требований, помощь клиенту и команде разработчиков и подтверждение качества
реализованной функциональности (STLC).
Общая цель - удовлетворение клиента и получение максимально возможного балла на этапах
верификации и валидации.

** Подходы к разработке/тестированию (... - driven development/testing)
Тут и там можно встретить упоминания различных подходов к разработке и тестированию на основе чего-то, здесь краткое описание самых часто встречающихся вариантов:

TDD - Test Driven Development: разработка на основе тестов основывается на повторении
коротких циклов разработки: изначально пишется тест, покрывающий желаемое изменение,
затем пишется программный код, который реализует желаемое поведение системы и позволит
пройти написанный тест. Затем проводится рефакторинг написанного кода с постоянной
проверкой прохождения тестов. Есть два уровня TDD:
1. Acceptance TDD (ATDD): вы пишете один приемочный тест. Этот тест удовлетворяет
требованиям спецификации или удовлетворяет поведению системы. После этого пишете
достаточно производственного / функционального кода, чтобы выполнить этот приемочный тест.
Приемочный тест фокусируется на общем поведении системы. ATDD также известен как BDD
- Behavior Driven Development;
2. Developer TDD: вы пишете один тест разработчика, то есть модульный тест, а затем
просто достаточно производственного кода для выполнения этого теста. Модульное
тестирование фокусируется на каждой небольшой функциональности системы. Это называется
просто TDD. Основная цель ATDD и TDD - определить подробные, выполнимые требования для
вашего решения точно в срок (JIT). JIT означает принятие во внимание только тех требований,
которые необходимы в системе, что повышает эффективность.
● BDD - Behaviour Driven Development: это разработка, основанная на описании поведения.
Определенный человек(или люди) пишет описания вида "я как пользователь хочу когда нажали
кнопку пуск тогда показывалось меню как на картинке" (там есть специально выделенные
ключевые слова). Программисты давно написали специальные тулы, которые подобные описания
переводят в тесты (иногда совсем прозрачно для программиста). А дальше классическая
разработка с тестами (TDD);
● TDD - Type Driven Development: при разработке на основе типов ваши типы данных и
сигнатуры типов являются спецификацией программы. Типы также служат формой документации,
которая гарантированно обновляется. Типы представляют из себя небольшие контрольные точки,
благодаря которым, мы получаем множество мини-тестов по всему нашему приложению;
● DDD - Domain Driven Design: Предметно-ориентированное проектирование не является
какой-либо конкретной технологией или методологией. DDD - это набор правил, которые
позволяют принимать правильные проектные решения. Это набор принципов и схем, направленных
на создание оптимальных систем объектов. Процесс разработки сводится к созданию
программных абстракций, которые называются моделями предметных областей. В эти модели
входит бизнес-логика, устанавливающая связь между реальными условиями области применения
продукта и кодом;
● FDD - Features Driven Development: представляет собой попытку объединить наиболее
признанные в индустрии разработки программного обеспечения методики, принимающие за основу
важную для заказчика функциональность (свойства) разрабатываемого программного обеспечения.
Основной целью данной методологии является разработка реального, работающего программного
обеспечения систематически, в установленные сроки;
● MDD - Model Driven Development: разработка, управляемая моделями - это стиль разработки
программного обеспечения, когда модели становятся основными артефактами разработки, из
которых генерируется код и другие артефакты;
● PDD - Panic Driven Development: это своеобразный антипаттерн разработки, который,
к сожалению, мы все время от времени практикуем. По сути это то, что получается, когда
процессы плохо налажены и команда импровизирует в условиях горящих сроков (новые задачи
приоритетнее старых, код решает конкретные срочные задачи, но копится технический долг,
тестирование в конце и т.д.);
● ADD - API Driven Development: разработка на основе API - это практика сначала
проектирования и создания API, а затем создания на их основе остальной части приложения;
● BDT - Behavior Driven Testing: в тестировании на основе поведения ваши тесты основаны
на user stories, которые описывают некоторые конкретные ожидаемые действия приложения.
Вместо проверки деталей реализации вы фактически проверяете то, что важно больше всего:
правильно ли приложение выполняет user stories. Еще одним преимуществом является понятность
тестов для менеджеров, аналитиков и т.п.;
● MDT - Model Driven Testing: Тестирование на основе моделей - это метод тестирования
черного ящика, при котором поведение тестируемого программного обеспечения во время
выполнения проверяется на основе прогнозов, сделанных моделями. Модель - это описание
поведения системы. Поведение может быть описано в виде наглядной схемы, Data Flow, Control
Flow, Dependency Graphs, Decision Tables, State transition machines или mind map.
Простой аналогией модели в тестировании является электрическая схема при разработке
электроприбора. Этот подход к тестированию требуется, когда высока цена ошибки в большом
продукте и нужно как можно раньше попытаться ее предотвратить;
● DDT - Data Driven Testing (table-driven testing or parameterized testing): в
тестировании на основе данных тестовые данные хранятся в виде таблицы. Оно позволяет
одним скриптом выполнять тесты для всех тестовых данных из таблицы и ожидать результатов 
теста в той же таблице;
● VDT - Value Driven Testing: тестирование на основе ценности - это подход, в основе
которого лежит анализ ценности и экономической целесообразности тестирования.

** Модели разработки ПО
● Чтобы лучше разобраться в том, как тестирование соотносится с программированием и иными
видами проектной деятельности, для начала рассмотрим самые основы -
модели разработки (lifecycle model) ПО (как часть жизненного цикла (software lifecycle) ПО). При этом сразу подчеркнем, что разработка ПО является лишь частью жизненного цикла ПО, и здесь мы говорим именно о разработке.
● Модель разработки ПО (Software Development Model, SDM) - структура,
систематизирующая различные виды проектной деятельности, их взаимодействие и
последовательность в процессе разработки ПО. Выбор той или иной модели зависит от
масштаба и сложности проекта, предметной области, доступных ресурсов и множества других
факторов. Выбор модели разработки ПО серьёзно влияет на процесс тестирования, определяя
выбор стратегии, расписание, необходимые ресурсы и т.д.

Водопадная модель (waterfall model) сейчас представляет скорее исторический интерес,
т.к. в современных проектах практически неприменима, исключая авиастроение, военную или
космическую отрасли, медицину и финансовый сектор. Она предполагает однократное
выполнение каждой из фаз проекта, которые, в свою очередь, строго следуют друг за другом.
Очень упрощенно можно сказать, что в рамках этой модели в любой момент времени команде
«видна» лишь предыдущая и следующая фаза. В реальной же разработке ПО приходится «видеть
весь проект целиком» и возвращаться к предыдущим фазам, чтобы исправить недоработки или
что-то уточнить.
К недостаткам водопадной модели принято относить тот факт, что участие пользователей
ПО в ней либо не предусмотрено вообще, либо предусмотрено лишь косвенно на стадии
однократного сбора требований. С точки зрения же тестирования эта модель плоха тем,
что тестирование в явном виде появляется здесь лишь с середины развития проекта, достигая
своего максимума в самом конце.

V-образная модель (V-model)
● V-модель (V-model): Модель, описывающая процессы жизненного цикла разработки программного
обеспечения с момента составление спецификации требований до этапа сопровождения.
V модель показывает интеграцию процессов тестирования в каждую фазу цикла разработки
программного обеспечения. (ISTQB)
● V-образная модель (V-model) является логическим развитием водопадной. Можно заметить
(рисунок 2.1.b), что в общем случае как водопадная, так и v-образная модели жизненного
цикла ПО могут содержать один и тот же набор стадий, но принципиальное отличие
заключается в том, как эта информация используется в процессе реализации проекта.
● Очень упрощенно можно сказать, что при использовании v-образной модели на каждой стадии
«на спуске» нужно думать о том, что и как будет происходить на соответствующей стадии
«на подъёме». Тестирование здесь появляется уже на самых ранних стадиях развития проекта,
что позволяет минимизировать риски, а также обнаружить и устранить множество
потенциальных проблем до того, как они станут проблемами реальными.

Итерационная инкрементальная модель (iterative model, incremental model)
● Инкрементная модель разработки (incremental development model): Модель жизненного цикла
разработки, в которой проект разделен на серию приращений, каждое из которых добавляет
часть функциональности в общих требованиях проекта. Требования приоритезированы и
внедряются в порядке приоритетов. В некоторых (но не во всех) версиях этой модели
жизненного цикла каждый подпроект следует «мини V-модели» со своими собственными фазами
проектирования, кодирования и тестирования. (ISTQB)
● Итеративная модель разработки (iterative development model): Модель жизненного цикла
разработки, в которой проект разделен обычно на большое количество итераций. Итерация
это полный цикл разработки, завершающийся выпуском (внутренним или внешним) рабочего
продукта, являющегося частью конечного разрабатываемого продукта, который разрастается
от итерации к итерации. (ISTQB)
● Итерационная инкрементальная модель является фундаментальной основой современного
подхода к разработке ПО. Ключевой особенностью данной модели является разбиение проекта
на относительно небольшие промежутки (итерации), каждый из которых в общем случае может
включать в себя все классические стадии, присущие водопадной и v-образной моделям.
Итогом итерации является приращение (инкремент) функциональности продукта, выраженное
в промежуточном билде (build).

Спиральная модель (spiral model)
Спиральная модель представляет собой частный случай итерационной инкрементальной модели,
в котором особое внимание уделяется управлению рисками, в особенности влияющими на
организацию процесса разработки проекта и контрольные точки.

Гибкая модель (agile model)
Гибкая методология разработки программного обеспечения (agile software development):
Группа методологий разработки программного обеспечения, основанных на итеративной
поэтапной разработке, где требования и решения развиваются посредством сотрудничества
между самоорганизующимися межфункциональными командами. (ISTQB)
Гибкая модель представляет собой совокупность различных подходов к разработке ПО и
базируется на т.н. «agile-манифесте». Положенные в основу гибкой модели подходы являются
логическим развитием и продолжением всего того, что было за десятилетия создано
и опробовано в водопадной, v-образной, итерационной инкрементальной, спиральной и иных
моделях. Причём здесь впервые был достигнут ощутимый результат в снижении бюрократической
составляющей и максимальной адаптации процесса разработки ПО к мгновенным изменениям
рынка и требований заказчика

** Agile
Agile - это способность создавать и реагировать на изменения. Это способ справиться с
неопределенной и неспокойной средой и в конечном итоге преуспеть в ней. Авторы Agile
Manifesto выбрали «Agile» в качестве названия всей этой идеи, потому что это слово
олицетворяет адаптивность и реакцию на изменения, которые так важны для их подхода.
На самом деле речь идет об осмыслении того, как вы можете понять, что происходит в среде,
в которой вы находитесь сегодня, определить, с какой неопределенностью вы сталкиваетесь,
и выяснить, как вы можете адаптироваться к этому по мере продвижения.
Гибкая разработка программного обеспечения - это общий термин для набора структур и
практик, основанных на ценностях и принципах, изложенных в Манифесте гибкой разработки
программного обеспечения и 12 принципах, лежащих в его основе. Когда вы подходите к
разработке программного обеспечения особым образом, обычно хорошо жить в соответствии
с этими ценностями и принципами и использовать их, чтобы помочь понять, что делать в
вашем конкретном контексте.
Одна вещь, которая отличает Agile от других подходов к разработке программного обеспечения,
- это сосредоточение внимания на людях, выполняющих работу, и на том, как они работают
вместе. Решения развиваются в результате сотрудничества между самоорганизующимися
кросс-функциональными командами, использующими соответствующие методы для своего контекста.
Agile-методологии - это условности, которым команда решает следовать в соответствии
с ценностями и принципами Agile. Вы, наверное, скажете: «Подождите, - я думал, что Scrum
и XP - это Agile-методологии». Алистер применил термин “framework” к этим концепциям. 

Ключевые концепции Agile
● Пользовательские истории (User Stories): после консультации с заказчиком или владельцем
продукта команда делит работу, которую необходимо выполнить, на функциональные этапы,
называемые «пользовательскими историями». Ожидается, что каждая пользовательская история
внесет свой вклад в ценность всего продукта;
● Ежедневные собрания (Daily Meeting): каждый день в одно и то же время группа собирается,
чтобы ознакомить всех с информацией, которая имеет жизненно важное значение для
координации: каждый член команды кратко описывает все «завершенные» вклады и любые
препятствия, стоящие на их пути;
● Персонажи (Personas): когда этого требует проект - например, когда пользовательский
опыт является основным фактором результатов проекта - команда создает подробные
синтетические биографии фиктивных пользователей будущего продукта: они называются personas;
● Команда (Team): «Команда» в Agile понимании - это небольшая группа людей, назначенных
на один и тот же проект или effort, почти все из них на постоянной основе. Незначительное
меньшинство членов команды может работать неполный рабочий день или иметь конкурирующие
обязанности;
● Инкрементальная разработка (Incremental Development): почти все Agile-команды отдают
предпочтение стратегии инкрементального развития; в контексте Agile это означает, что
можно использовать каждую последующую версию продукта, и каждая основывается на предыдущей
версии, добавляя видимые для пользователя функциональные возможности;
● Итеративная разработка (Iterative Development): Agile-проекты являются итеративными,
поскольку они намеренно позволяют «повторять» действия по разработке программного
обеспечения и потенциально «пересматривать» одни и те же рабочие продукты;
● Ретроспектива (Milestone Retrospective): после того, как проект был запущен в течение
некоторого времени или в конце проекта, все постоянные члены команды (не только
разработчики) вкладывают от одного до трех дней в подробный анализ значимых событий
проекта.

Существуют методологии, которые придерживаются ценностей и принципов заявленных в Agile
Manifesto, некоторые из них:
● Agile Modeling - набор понятий, принципов и приемов (практик), позволяющих быстро
и просто выполнять моделирование и документирование в проектах разработки программного
обеспечения. Не включает в себя детальную инструкцию по проектированию, не содержит
описаний, как строить диаграммы на UML. Основная цель: эффективное моделирование и
документирование; но не охватывает программирование и тестирование, не включает вопросы
управления проектом, развертывания и сопровождения системы. Однако включает в себя
проверку модели кодом.
● Agile Unified Process (AUP) упрощенная версия IBM Rational Unified Process (RUP),
разработанная Скоттом Амблером, которая описывает простое и понятное приближение (модель)
для создания программного обеспечения для бизнес-приложений.
● Agile Data Method- группа итеративных методов разработки программного обеспечения,
в которых требования и решения достигаются в рамках сотрудничества разных кросс-функциональных команд.
● DSDM основан на концепции быстрой разработки приложений (Rapid Application Development,
RAD). Представляет собой итеративный и инкрементный подход, который придаёт особое
значение продолжительному участию в процессе пользователя/потребителя.
● Essential Unified Process (EssUP).
● Экстремальное программирование (Extreme programming, XP).
● Feature driven development (FDD) - функционально-ориентированная разработка.
Используемое в FDD понятие функции или свойства (англ. feature) системы достаточно
близко к понятию прецедента использования, используемому в RUP, существенное отличие
- это дополнительное ограничение: «каждая функция должна допускать реализацию не более,
чем за две недели». То есть если сценарий использования достаточно мал, его можно считать
функцией. Если же велик, то его надо разбить на несколько относительно независимых
функций.
● Getting Real - итеративный подход без функциональных спецификаций, использующийся
для веб-приложений. В данном методе сперва разрабатывается интерфейс программы, а потом
её функциональная часть.
● OpenUP - это итеративно-инкрементальный метод разработки программного обеспечения.
Позиционируется как легкий и гибкий вариант RUP. OpenUP делит жизненный цикл проекта
на четыре фазы: начальная фаза, фазы уточнения, конструирования и передачи. Жизненный
цикл проекта обеспечивает предоставление заинтересованным лицам и членам коллектива
точек ознакомления и принятия решений на протяжении всего проекта. Это позволяет
эффективно контролировать ситуацию и вовремя принимать решения о приемлемости результатов.
План проекта определяет жизненный цикл, а конечным результатом является окончательное
приложение.
● Scrum устанавливает правила управления процессом разработки и позволяет использовать
уже существующие практики кодирования, корректируя требования или внося тактические
изменения. Использование этой методологии дает возможность выявлять и устранять
отклонения от желаемого результата на более ранних этапах разработки программного продукта.
● Бережливая разработка программного обеспечения (lean software development) использует
подходы из концепции бережливого производства.

Манифест тестирования в Agile:
постоянное тестирование, а не только в конце разработки;
предотвращение багов более значимо, чем их поиск;
понимание тестируемого продукта выше проверки функционала;
построение лучшей системы в связке с командой выше поиска методов ее сломать;
вся команда отвечает за качество, а не только тестировщик.

Особенности тестирования в Agile
В Agile, тестирование - это ответственность каждого. Критерий качества должен соблюдаться
на протяжении всего цикла. В то время как бизнес-аналитики сосредотачиваются на создании
подробных пользовательских историй, разработчики сосредотачиваются на разработке
качественного кода, QA несет ответственность за уточнение критериев приемлемости для
каждой пользовательской истории, тестирование завершенной функциональности в каждом
спринте с точки зрения клиента и проверка всей ранее выполненной функциональности.
Роли и ответственность QA не ограничиваются только тестированием в Agile, но также
включают в себя следующее:
● QA работают в тесном сотрудничестве с владельцами продуктов, бизнес-аналитиками и
командой разработчиков, чтобы понять разрабатываемый продукт, для кого он предназначен
и каковы будут критерии успеха продукта.
● Они углубляются в критерии приемки, созданные бизнес-аналитиками, для написания
тестовых примеров, визуализации рабочего процесса, тестирования стандартных элементов
и проведения негативного тестирования.
● Опытный QA также хорошо осведомлен об объеме выпуска и соответственно устанавливает
границы своего тестирования.
● Тестировщики должны общаться с командой и задавать вопросы во время тестирования, что
позволяет им выявлять пробелы в требованиях или получать ответы на нерешенные вопросы.
Коммуникация и сотрудничество с командой имеют решающее значение, поскольку они помогают
сделать тестирование более точным и надежным. Это также помогает достичь необходимого
темпа, чтобы двигаться быстрее, с ранними отзывами о тестировании и повышенным качеством.
● Как член Agile команды, тестировщик всегда должен быть синхронизирован с командой проекта,
посещая сессии планирования спринтов для выявления возможных проблемных областей и
ежедневных митингов для содействия сотрудничеству. Посещение ретроспективы спринта дает
возможность выявить слабые места и определить решения внутри команды. Посещение митингов
по обзору спринта или демонстрации продукта позволяет тестировщику увидеть, как работает
новая функция, и дает им возможность задать важные вопросы разработчикам.
● Документирование сценариев тестирования и выполнения тестов с доказательствами важно
для тестировщиков, но оно должно быть минимальным и кратким.

** Scrum
Scrum - наиболее популярный Agile-фреймворк, для многих людей эти термины являются
синонимами. Scrum - это фреймворк процесса, используемый для управления разработкой
продукта и другой работой, связанной с знаниями. Скрам является эмпирическим в том смысле,
что дает командам возможность установить гипотезу о том, как они думают, что что-то
работает, опробовать это, проанализировать полученный опыт и внести соответствующие
коррективы. То есть при правильном использовании фреймворка. Скрам структурирован таким
образом, чтобы команды могли использовать практики из других фреймворков, которые имеют
смысл для контекста команды.
Scrum лучше всего подходит в случае, когда кросс-функциональная команда работает в среде
разработки продукта, где есть нетривиальный объем работы, которую можно разделить на
более чем одну 2-4-недельную итерацию.

Ценности:
● Преданность (Commitment): Члены команды лично привержены достижению целей команды;
● Смелость (Courage): Члены команды поступают правильно и работают над сложными
проблемами;
● Сфокусированность (Focus): Сконцентрируйтесь на работе, намеченной для спринта,
и целях команды;
● Открытость (Openness): Члены команды и заинтересованные стороны открыто рассказывают
обо всей работе и проблемах, с которыми сталкивается команда;
● Уважение (Respect): Члены команды уважают друг друга за способности и независимость.

Принципы:
● Прозрачность (Transparency): Команда должна работать в среде, где каждый знает,
с какими проблемами сталкиваются другие члены команды. Команды выявляют проблемы внутри
организации, часто возникающие в течение длительного времени, которые мешают успеху
команды;
● Инспекция (Inspection): Частые контрольные точки встроены в структуру, чтобы дать
команде возможность поразмышлять о том, как работает процесс. Эти контрольные точки
включают в себя Daily Scrum meeting и the Sprint Review Meeting;
● Адаптация (Adaptation): Команда постоянно изучает, как идут дела, и проверяет те
пункты, которые кажутся бессмысленными.

Артефакты:
● Бэклог продукта (Product Backlog): это упорядоченный список всех возможных изменений,
которые могут быть внесены в продукт. Пункты в бэклоге продукта являются вариантами, а не
обязательствами, и то, что они существуют в бэклоге продукта, не гарантирует, что они
будут доставлены. Владелец продукта постоянно ведет бэклог продукта, включая его
содержание, доступность и порядок;
● Бэклог спринта (Sprint Backlog): это набор элементов из бэклога продукта, выбранных для
доставки в спринте. После того, как команда определяет задачи, эти задачи необходимо
выполнить для достижения цели спринта (Sprint Goal);
● Инкремент (Increment): это набор элементов из бэклога продукта, которые соответствуют
Definition of Done к концу спринта. Владелец продукта может решить выпустить дополнение
или развить его в будущих Спринтах;
● Критерии Готовности (Definition of Done): это общее соглашение команды о критериях,
которым должен соответствовать элемент бэклога продукта, прежде чем он будет считаться
выполненным$
● Пользовательские истории (User Story);
● Цель спринта (Sprint Goal);
● Диаграмма сгорания задач (Burndown chart).

Жизненный цикл Scrum:
● Создайте бэклог продукта;
● Владелец продукта и команда разработчиков проводят планирование спринта. Определите
объем спринта в первой части планирования спринта и план реализации этого объема во
второй половине планирования спринта;
● По мере продвижения спринта команда разработчиков выполняет работу, необходимую для
доставки выбранных элементов бэклога продукта;
● Команда разработчиков ежедневно координирует свою работу в рамках Daily Scrum;
● В конце спринта группа разработчиков предоставляет элементы бэклога продукта, выбранные
во время планирования спринта. Команда разработчиков проводит обзор спринта, чтобы
показать клиенту инкремент и получить обратную связь. Команда разработчиков и владелец
продукта также размышляют о том, как прошел Sprint до сих пор, и соответствующим образом
адаптируют свои процессы во время ретроспективы;
● Команда повторяет шаги 2-5 до тех пор, пока не будет достигнут желаемый результат.