
** https://doka.guide/js/api/
Разные программы могут быть написаны на разных языках.
Это очевидно, и на первый взгляд кажется, что не вызывает никаких проблем.
На деле же, если программы написаны на разных языках, их может быть трудно «подружить» и сделать так,
чтобы они могли друг с другом «общаться».
Именно для того, чтобы подружить разные модули, системы, языки, программы — и существуют API.
Когда нам нужны какие-то данные, мы запрашиваем их у сервера. Однако сервер написан, скорее всего,
не на JavaScript, а на каком-то другом языке: Python, C#, Java. Чтобы сервер понял, что мы от него хотим,
нам нужно как-то объяснить наш запрос.
Именно для этого нужно API — оно позволяет разным системам общаться, понимая друг друга.
API (Application Programming Interface) — это набор фич, которые одна программа представляет всем остальным.
Она как бы говорит: «Смотрите, со мной можно говорить вот так и вот так, можете меня спросить
о том-то через эту часть, а попросить что-то сделать — через эту».
В случае c клиент-серверным общением (см. Как работают веб-приложения) API может выступать
как набор ссылок, по которым клиент обращается на сервер:
POST /api/v1.0/users — для создания пользователя;
GET /api/v1.0/users — для получения списка пользователей.
API может использоваться не только для общения браузера и сервера, но и в принципе
для общения разных программ друг с другом.
Какие API бывают
REST
Секция статьи "REST"
REST (Representational State Transfer) — стиль общения компонентов, при котором все необходимые данные
указываются в параметрах запроса.
Отличительная особенность этого стиля — это стиль построения адресов и выбор метода.
Всё взаимодействие между клиентом и сервером сводится к 4 операциям (CRUD):
созданию чего-либо, например, объекта пользователя(create, C);
чтению (read, R);
обновлению (update, U);
удалению (delete, D).
Для каждой из операций есть собственный HTTP-метод:
● POST для создания;
● GET для чтения;
● PUT, PATCH для обновления;
● DELETE для удаления.
API для интернет-магазина, то CRUD для заказа мог бы выглядеть следующим образом:
● POST /api/orders/ — создать новый заказ.
Как правило, в ответ на POST-запрос сервер возвращает ID созданной сущности, в нашем случае — ID заказа.
Пусть будет 42.
● GET /api/orders/42 — получить заказ с номером 42.
В ответ мы получим JSON, XML, HTML с данными о заказе (сейчас чаще всего — JSON).
● PUT /api/orders/42 — обновить заказ с номером 42. Вместе с запросом мы отправляем данные,
которыми надо обновить этот заказ. В ответ сервер ответит или статусом 204
(всё хорошо, но контента в ответе нет), или ID обновлённой сущности.
● DELETE /api/orders/42 — удалить заказ с номером 42. Как правило, в ответ присылается или 204,
или ID удалённой сущности.
SOAP
Вообще, не очень корректно сравнивать SOAP и REST, потому что REST — это архитектурный стиль,
а SOAP — формат обмена данными.
SOAP (Simple Object Access Protocol) — формат обмена данными.
Это структурированный формат обмена данными, то есть каждое сообщение следует определённой структуре.
Чаще всего вместе с SOAP используется XML для отражения этой структуры.
Сама структура выглядит так:
nvelope — корневой элемент, который определяет само сообщение.
Header содержит атрибуты сообщения, например: информацию о безопасности.
Body содержит сообщение, которым обмениваются приложения.
Fault необязательный элемент с ошибками обработки, если они были.
При этом в SOAP неважно, каким методом передавать сообщения, в отличие от REST.
SOAP не очень прижился, потому что достаточно многословен и неудобен для работы на клиенте:
XML проигрывает JSON, а SOAP, построенный на JSON — это довольно редкий случай.
Плюсы:
не зависит от методов передачи; есть структура сообщения.
Минусы
многословен; проигрывает REST в простоте.
RPC
RPC (Remote Procedure Call) — это такой стиль, при котором в сообщении запроса хранится и действие,
которое надо выполнить, и данные, которые для этого действия нужны.
Так как мы больше говорим о вебе, то можно грубо сказать, что RPC
— это «вызов серверной функциональности из браузера».
В вебе более часто использовались XML-RPC и JSON-RPC. Мы будем рассматривать примеры на JSON-RPC,
просто потому что JSON сейчас используется чаще, и его проще читать.
Сообщение-запрос по протоколу JSON-RPC должно иметь 3 обязательных поля:
● method — строка с именем вызываемого метода.
● params — массив данных, которые должны быть переданы методу, как параметры.
● id — значение любого типа, которое используется для установки соответствия между запросом и ответом.
В ответ сервер должен прислать сообщение, содержащее:
● result — данные, которые вернул метод. Если произошла ошибка во время выполнения метода,
это свойство должно быть установлено в null.
● error — код ошибки, если произошла ошибка во время выполнения метода, иначе null.
● id — то же значение, что и в запросе, к которому относится этот ответ.
Плюсы:
есть структура сообщения; использует JSON, что делает его проще для чтения и написания;
производителен, если нужны batch-запросы.
Минусы:
слишком много логики уходит на клиент;
HTTP-кэширование недоступно.

** https://appmaster.io/ru/blog/chto-takoe-rest-api-i-chem-ono-otlichaetsya-ot-drugogo-api
API представляет набор правил и функций,
позволяющих двум разным приложениям взаимодействовать друг с другом.
Подобные интерфейсы облегчают интеграцию приложений,
давая возможность разработчикам создавать мощные диджитал решения.
API выступает посредником между приложениями, отправляя запросы и ответы. 
Для отправки и получения тех самых запросов (функций) и в зависимости от назначения
API следует разным протоколам и стандартам.
Различают следующие типы протоколов и архитектур:
● XML-RPC — позволяет выполнять обмен функциями между двумя или более сетями. XML-RPC использует
XML для описания запросов и ответов, и при помощи протоколов HTTP передает информацию от клиента к серверу. 
● JSON-RPC — это облегченный RPC, похожий на XML. Протокол закодирован в JSON,
позволяет получать вызовы на сервер с возможностью асинхронных ответов.
● SOAP — simple object access protocol — протокол для обмена структурированной информацией при
реализации веб-сервисов в компьютерных сетях. SOAP использует XML для аутентификации, авторизации и
взаимодействия процессов в операционных системах и позволяет клиентам вызывать веб-сервисы
и получать ответы независимо от языка и платформы.
● REST API — репрезентативная передача состояния (REST) — это архитектурный стиль,
который осуществляет реализацию клиента и сервера независимо друг от друга.
Сервисы в REST API взаимодействуют по протоколу HTTP.

REST или Representational state transfer, что переводится как передача состояния представления — это
архитектурный стиль проектирования API с использованием протокола HTTP. Главное преимущество REST
— большая гибкость.
Применяется везде, где есть необходимость предоставления данных с сервера пользователю веб-приложения или сайта
Главными компонентами REST API являются:
Client — клиент или программа, которая запущена на стороне пользователя инициирует коммуникацию.
Server — сервер, который предоставляет API в качестве доступа к своим данным и функциям.
Resource — ресурс представляет собой любой вид контента (видео, текст, картинка),
который сервер может передать клиенту.

Как работает REST API
REST API взаимодействует при помощи HTTP запросов, выполняя стандартные функции: создание, обновление, чтение,
удаление записей в ресурсе. Существует четыре метода, описывающих, что нужно делать с ресурсом:
POST — создание ресурса;
GET — получение ресурса;
PUT — обновление ресурса;
DELETE — удаление ресурса.
Ресурс
Ресурс — это ключевая абстракция информации. Любой вид информации, который мы можем использовать,
может быть ресурсом: документ, изображение, временный сервис.
Состояние ресурса в любой определенный момент называется представлением ресурса. Оно состоит из:
данных;
метаданных, описывающих данные;
гипермедиа ссылок, которые помогают клиентам перейти в следующее состояние.
Эта информация доставляется клиенту в любом формате: JavaScript (JSON), HTML, XLT, Python, PHP или простой текст.
JSON наиболее популярен, потому что он читабелен для машин и людей и не зависит от языка программирования.
Чтобы получить доступ к ресурсу, клиент отправляет запрос.
Сервер генерирует ответ с закодированными данными о ресурсе.
Структура любого запроса включает в себя четыре основных компонента:
HTTP метод (о которых мы говорили ранее), эндпоинты, заголовки и тело.
HTTP метод описывает, что должно быть сделано с ресурсом.
Чуть выше мы упоминали 4 доступных метода:POST, GET, PUT, DELETE.
Эндпоинт содержит URI — Uniform Resource Identifier (унифицированный идентификатор ресурса), который указывает,
где и как найти ресурс в Интернете. Самый распространенный тип URI — это URL или Uniform Resource Location,
который является полноценным веб-адресом.
Заголовки хранят информацию, относящуюся как к клиенту, так и к серверу. Главным образом, заголовки предоставляют
аутентификационные данные: API ключ, название или IP адрес компьютера, на котором установлен сервер,
а также информацию о формате ответа. 
Тело необходимо для передачи серверу дополнительной информации: данные тела body — это данные,
которые вы, к примеру, хотите добавить или заменить.

Принципы REST API
REST не привязан к какой-либо конкретной технологии или платформе, он не зависит от языка.
Он также не указывает, как именно создавать API, но использует 6 архитектурных ограничений,
которые должны быть соблюдены, чтобы интерфейс можно было назвать RESTful.
Именно эти принципы REST API описывают, как сервер обрабатывает запросы и отвечает на них.
● Client-server
Приложение REST имеет клиент-серверную архитектуру. Клиентом является тот, кто отправляет запросы на ресурсы
и никак не связан с хранилищем данных. Хранение данных остается внутри сервера.
Серверы же не связываются с пользовательским интерфейсом. Другими словами, клиент и сервер независимы друг от друга
и могут развиваться отдельно, что делает REST API более гибким и масштабируемым.
● Uniform Interface
Унифицированный интерфейс или единый интерфейс — это главное, что отличает REST API от других видов.
Он предполагает наличие единого способа взаимодействия с сервером вне зависимости от типа устройства или приложения.
Единый интерфейс включает в себя четыре основных принципа: 
-Identification of resources. Каждый ресурс в REST имеет идентификатор, который не зависит от состояния ресурса.
В роли идентификатора выступает URL.
-Manipulation of resources through representations (манипулирование ресурсами через представления).
Клиент имеет представление ресурса, которое содержит данные для его удаления или изменения.
Клиент отправляет представление на сервер (объект JSON), который он хочет изменить, удалить или добавить.
-Self-descriptive messages (самодокументируемые сообщения). Такие сообщения содержат нужную информацию для получателя,
чтобы понять ее. Никакой дополнительной информации не требуется в отдельной документации или сообщениях.
Каждое сообщение имеет достаточную информацию, чтобы сервер легко проанализировал запрос.
-Hypermedia as the engine of application state (гипермедиа как двигатель состояния приложения).
Гипермедиа подразумевает использование ссылок для каждого ответа, чтобы клиент мог найти другие ресурсы.
Таким образом все взаимодействия в REST проходят через гипермедиа.
● Stateless (без состояния)
Сервер не содержит никакой информации о клиенте. Каждый запрос включает всю необходимую информацию для обработки.
Информация о сессии полностью хранится на стороне клиента.
● Cacheable (кэшируемость)
Каждый ответ должен содержать данные о том, является ли он кэшируемым или нет и в течение какого времени
ответ может быть кэширован на стороне клиента. Если ответ может быть кэширован, то в последующих похожих запросах клиент
может использовать те же данные без повторного обращения на сервер.
При правильном использовании это улучшает производительность и доступность.
● SLayered system (многоуровневая система)
В REST используется многоуровневая система — иерархия слоев, которая создает определенные ограничения
на поведение компонентов. В многоуровневой системе, компоненты могут видеть только те компоненты,
которые расположены на ближайших уровнях и с которыми они взаимодействуют.
● SCode on demand (код по запросу)
Это опциональная функция, которая позволяет клиенту загружать и выполнять код.

Главные отличия REST API от других API
Шесть принципов REST API являются основными отличиями интерфейса от других типов.
Помимо этого, есть еще несколько параметров, которые отличают REST от других API.
● В первую очередь, сама суть REST определяет его несопоставимость с другими протоколами. REST — это архитектурный стиль,
где архитектура REST представляет набор требований, которым нужно следовать, чтобы предоставить веб-службу RESTful.
A, например, SOAP и RPC являются протоколами обмена сообщениями. Протокол описывает эти сообщения,
когда архитектурный REST API только определяет требования (в данном случае ограничения), которые сообщения должны выполнять.
● Структура
Большинство программных интерфейсов работают в формате приложение-приложение, когда REST действует по принципе Клиент-Сервер.
В данном случае клиент и сервер не зависят друг от друга, что дает больше гибкости в работе.
● Формат обмена сообщениями
Обычно API используют конкретные форматы сообщений, например, SOAP использует XML. REST не придерживается
такого строгого принципа. Обмен сообщений может происходить на основе JSON, XML или любого другого формата.
Самым популярным является JSON (JavaScript Object Notation).
● Гибкость
REST является более гибкой архитектурой, благодаря чему и стал таким популярным. 
Он решает проблемы, которые вызывает тот же SOAP, являясь сложным протоколом с расширенными функциями безопасности,
что требует большей пропускной способности.
REST состоит из простых рекомендаций, давая возможность разработчикам реализовывать требования в своем формате.
Архитектурный стиль также имеет высокую производительность. Что сделало особенно востребованным для мобильных устройств,
где быстрота загрузки особенно важна.

** https://habr.com/ru/post/131343/ 
Сравение подходов SOAP и REST.
● SOAP – это целое семейство протоколов и стандартов, откуда напрямую вытекает, что это более тяжеловесный
и сложный вариант с точки зрения машинной обработки. Поэтому REST работает быстрее.
● SOAP используют HTTP как транспортный протокол, в то время как REST базируется на нем. Это означает,
что все существующие наработки на базе протокола HTTP, такие как кеширование на уровне сервера, масштабирование,
продолжают так же работать в REST архитектуре, а для SOAP необходимо искать другие средства.
Взамен этого SOAP сервисы получают такое мифическое свойство, как возможность работать с любым протоколом
транспортного уровня вместо HTTP, однако практической пользы от него зачастую не больше, чем сотрудникам Челябинского
трубопрокатного завода от большого количесва статей в википедиях на мертвых языках.
● Есть мнение, что разработка RESTful сервисов намного проще. Наверное, это правда, если использовать Notepad
в качестве основной среды разработки, но вот с использованием наших чудесных средств разработки,
я позволю себе усомниться в верности этого утверждения.
● В первом гугловском результате по запросу «REST vs SOAP» акцентируется внимание на том, что ответ REST может быть
представлен в различных форматах, а SOAP привязан к XML. Это действительно важный фактор, достаточно представить
себе вызов сервиса из javascript, ответ на который мы определенно хотим получать в JSON.
● «REST vs SOAP» можно перефразировать в «Простота vs Стандарты», что проявляется в том, что для SOAP
мы имеем протокол WSDL для исчерпывающего описания веб-сервиса, который с использованием все тех же чудесных
средств разработки прото-таки волшебным образом делает почти всю работу за нас. Со стороны REST мы имеем загадочный
и неиспользуемый протокол WADL, который, в принципе, и не нужен – он мешает простоте.
● Второй аспект предыдущего пункта – обработка ошибок. В SOAP она полностью стандартизована, а REST может использовать
давно известные коды ошибок HTTP (если здесь Вас посетила мысль, что это же очевидно и зачем я это пишу,
то значит Вы внимательно читаете статью).
● То, с чего можно было бы начать, но я припас напоследок. Это одна из ключевых мыслей. SOAP работает с операциями,
а REST – с ресурсами. Этот факт в совокупности с отсутствием клиентского состояния у RESTful сервисов приводит нас к тому,
что такие вещи как транзакции или другая сложная логика должна реализовываться «SOAP-но».

SOAP популярен для комплексных корпоративных проектов, где применяется сложная замысловатая логика и необходимы единые
стандарты, актуальные для продолжительного использования (комплексная автоматизация для больших предприятий создаётся годами).

** https://medium.com/maddevs-io/introduction-to-grpc-6de0d9c0fe61
gRPC — это высокопроизводительный фреймворк разработанный компанией Google для вызов удаленных процедур (RPC),
работает поверх HTTP/2.
gRPC простой в использовании, отлично подходит для создания распределенных систем (микросервисов) и API.
Имеет встроенную поддержку для балансировки нагрузки, трассировки, аутентификации и проверки жизнеспособности сервисов.
Есть возможность создавать клиентские библиотеки для работы с бэкендом на 10 языках. Высокая производительность
достигается за счет использования протокола HTTP/2 и Protocol Buffers.

Protocol Buffers (protobuf)
Protobuf формат сериализации используемый по умолчанию для передачи данных между клиентом и сервером.
Используя строгую типизацию полей и бинарный формат для передачи структурированных данных потребляет меньше ресурсов.
Время выполнения процесса сериализации/десериализации значительно меньше как и размер сообщений в отличии от JSON/XML.
Пример profile.proto
message Profile {
  reserved 3; // Резервируем поле под номером 3
  int32 id = 1;
  string name = 2;
  int32 age = 4;
  string email = 5;
  enum PhoneType {
    MOBILE = 0;  // Поле 0 является значением по умолчанию
    HOME = 1;
    WORK = 2;
  }
  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }
  
  repeated PhoneNumber phones = 6;
}

Типы RPC
● Унарный (Unary RPC). Синхронный запрос клиента, который блокируются пока не будет получен ответ от сервера.
● Серверный стрим (Server streaming RPC), при подключении клиента сервер открывает стрим и начинает отправлять сообщения.
● Клиентский стрим (Client streaming RPC). То же самое, что и серверный, только клиент начинает стримить сообщения на сервер.
● Двунаправленный стрим (Bidirectional streaming). Клиент инициализирует соединение, создаются два стрима.
● Сервер может отправить изначальные данные при подключении или отвечать на каждый запрос клиента по типу “пинг-понга”.

Перехватчики (Interceptors)
Выступают этакой заменой мидлварям, служат для перехвата вызовов и встраивания необходимых условий.
Отлично подходят для логирования запросов, сбора метрик, аутентификации и т.д. Пример подключения логов,
мониторинга и аутентификации для всех типов запросов используя пакет go-grpc-middleware:
import "github.com/mwitkow/go-grpc-middleware"
myServer := grpc.NewServer(
    grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(loggingStream, monitoringStream, authStream)),
    grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(loggingUnary, monitoringUnary, authUnary),
)

Балансировка нагрузки (Load Balancing)
Выполняется на стороне клиента. Клиент использует простой “round-robin” алгоритм для передачи запросов по списку
полученному от LB сервера. При желании на стороне LB сервера можно организовать более сложный алгоритм
выдачи списка бэкенд сервисов клиенту использую LB политики.

** https://doka.guide/tools/web-server/
Модули и расширения
Первые веб-серверы могли передавать только текстовую информацию.
Современные веб-серверы работают с файлами различных форматов, позволяют предварительно сжимать
и шифровать передаваемые данные, исполнять код на различных языках и привязывать его к контексту запросов и ответов.
Вся эта богатая функциональность реализуется с помощью модулей и плагинов.

● Сжатие данных
Загрузка страниц будет происходить быстрее, если размер ответа сервера будет маленьким.
Поэтому любой современный сервер содержит модуль сжатия. Перед отправкой клиенту данные запаковываются,
а на стороне клиента распаковываются с помощью одного из алгоритмов сжатия.
Долгое время для этого использовался формат сжатия gzip, и все популярные браузеры его поддерживают.
В последние годы браузеры стали поддерживать ещё два формата: zopfli и brotli.
Наиболее перспективным и эффективным является brotli, он поддерживается всеми современными браузерами.
● Шифрование данных
При передаче данных пользователей важно их шифровать. Интернет построен так,
что пакеты данных пользователей проходят множество сетевых узлов, прежде чем окажутся на целевом устройстве.
Если данные не зашифрованы, то каждый из промежуточных узлов может просматривать их в открытом виде.
● Проксирование
Современные веб-серверы способны не только отправлять файлы по запросу пользователя,
но и перенаправлять запросы клиентов другой программе. Например, можно передать данные другому веб-серверу,
который будет специализироваться на определённом типе файлов, или программе-интерпретатору, которая будет исполнять код,
получать нужные данные, отдавать их веб-серверу с целью передать их, в конечном счёте, клиенту.
Само перенаправление запросов и ответов называется проксированием.
● Куки
Веб-сервер не только отдаёт данные. Например, можно получить доступ к кукам браузера пользователя со стороны веб-сервера.
Это позволяет сохранять промежуточные данные, которые могут помочь улучшению пользовательского опыта.
Существуют и проблемы такой модели, которые связаны с приватностью пользователей в Интернете и их безопасностью.
● Аутентификация и авторизация
- Идентификация — процесс присваивания какого-либо имени объекту (например, пользователю или программе).
Когда человек покупает билет на поезд или самолёт, необходимо представиться.
В этот момент он проходит процедуру идентификации.
- Аутентификация — подтверждение подлинности объекта. При покупке билета или уже на стойке регистрации нужно
предъявить паспорт, чтобы доказать, что это тот самый человек, на которого оформлен билет.
То есть аутентифицировать — значит подтвердить идентификатор объекта.
- Авторизация — предоставление прав объекту на что-то. Если человек приходит с билетом на стойку регистрации
или к вагону поезда и предъявляет билет и паспорт, ему выдают посадочный талон
— возможность долететь / доехать и сопутствующие услуги, согласно классу обслуживания.
Для аутентификации пользователей нужно отдать веб-серверу учётные данные пользователя, то есть представиться и
предъявить пару имени пользователя и пароля в качестве доказательства, что это тот самый пользователь.
Веб-сервер может самостоятельно обработать запрос или передать их приложению, в котором реализуется процедура аутентификации.
В случае успешной аутентификации приложение посылает клиенту ответ с уникальным ключом через веб-сервер (токеном),
который определяет сессию пользователя. То есть в этот момент происходит процедура авторизации.
С этого момента и до окончании сессии (до выхода из аккаунта) во все запросы клиента встраивается специальный заголовок.
Ключ обозначает наличие у пользователя определённых прав. Согласно этим правам пользователю и предоставляются данные,
предназначенные только ему.
Аутентификация при этом происходит не на сервере, а на стороннем ресурсе. В результате аутентификации формируется токен,
который передаётся серверу. После подтверждения личности, пользователю предоставляются определённые права (процедура авторизации),
назначается специальный токен сессии, который также передаётся в заголовках вместе с запросами от клиента.
При использовании кук на клиенте создаётся отдельная запись, в которой указывается уникальный токен сессии.
Веб-сервер имеет доступ к этому токену, что позволяет всегда проверить факт авторизации.
Есть и другие способы аутентификации и авторизации, которые поддерживаются веб-сервером.
● Кэширование
Веб-сервер проводит мониторинг и кэширует ответы клиентам. Это происходит автоматически.
Если запросы совпадают, то веб-сервер формирует обновляемый кэш, из которого он сразу отдаёт ответ клиенту,
не выполняя обработку запроса. Время обновления актуальности ответа
и стратегия кэширования устанавливается в настройках веб-сервера.
Веб-серверы могут обеспечить кэширование и на стороне клиента, чтобы снизить нагрузку на сеть.
Для работы с кэшированием используются специальные заголовки. Например, сервер может передать заголовок клиенту:
Cache-Control: public, max-age=31536000
Такой заголовок сообщит клиенту, что запрошенные данные можно не обновлять целый год (в параметре max-age указывается кол-во секунд).
Для статического контента, который редко обновляется или не обновляется вовсе, такой подход позволяет сэкономить массу трафика в сети.