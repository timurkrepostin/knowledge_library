
** Ksendzoff course_theory
1. Когда в браузере (программа-клиент), в который сервер отправляет HTML, CSS, JS файлы,
производится запрос, запрос летит в центральный комутатор, после в DNS в котором по названию
домена переводит в их уникальный ip адрес, и после прилетает на сам сервер, который дает ответ
клиенту, проходя тот же путь в обратном порядке

2. Приведя аналогию дома, если Server - дом, то port - домофон. Если запустить на сервере 
два http сервера, то один может быть на 5005, второй на 5007

3. API, ключевое слово слово interface - элемент управления системой

4. EndPoint - API состоит из EndPoint'ов и при взаимодействии с каждым EndPoint'ом 
сервер отправляет определенный ответ

5. Отдать ответ значит отправить пакет данных состоящий из HTML, CSS, JS - файлов,
подтянуть что-то из БД и отправить на клиент

6. Фронтенд - разработчики пишут файлы, которые в конечном итоге подхватит бэкенд
и отправит клиенту при определенном запросе

7. Работа архитектуры на примере логина на абстрактном сайте:
- Отправляем url login, чтобы сервер поймал эндпоинт login, после чего он отправит набор
HTML, CSS, JS - файлов, благодаря которым на клиенте отрисуется странице логина;
- После того, как заполнили форму и нажали кнопку логин, начинает работать скрипт валидации,
чтобы проверить все ли в норме, если все ок - 
срабатывает скрипт отправки запроса на сервер в эндпоинт loginUser
- Запрос при логине производится методом POST, поэтому скрипт формирует JSON-файл
с данными пользователя, который кладется в body тела запроса, в HEAD указывается EndPoint
- На сервер приходит запрос в EndPoint loginUser, забирается логин и пароль
и происходит следующая логика:
- Запрос с логином с сервера отправляется в базу данных с сервера, база данных дает ответ, 
происходит идентификация, что такой пользователь в системе есть
- Далее проверяется пароль, тот ли это user, происходит аутентификация, когда подтверждается
- Проверяется этот user может в системе и что ему можно (права пользователя), это авторизация
- После того, как три фактора сошлись, сервер отправляет ответ пользователю со страницей личного
кабинета, данные личного кабинета подтягиваются из БД
- Пользователь получает доступ к личному кабинету со всеми своими личными данными и пропуск -
токен, являющийся уникальным идентификатором залогининого пользователя 
- Когда пользователь, решит что-то проверить по личному кабинету, при отправке запроса
на это будет прикладываться токен, который обрабатывает сервер на наличие 
прав на данное действие у пользователя, токен может закладываться в куки

8. Сервер может стать клиентом, отправляя запросы по определенным EndPoint на 3rd-party 

** Doka guide https://doka.guide/js/web-app-works/
1. Любое веб-приложение, если оно работает в браузере, работает на 3 основных технологиях:
HTML, CSS и JS.

2. Хранением и обработкой данных обычно занимается сервер или бэкенд.
Бэкенд — область веб-технологий, работающих на сервере, а также внутренняя часть серверной системы,
занимается обработкой данных.

3. При описании архитектуры мы не вдаёмся в подробности каждого конкретного модуля,
а скорее описываем их взаимодействие между собой, «фиксируем договорённости» поведения каждого из них.
Клиент-серверная архитектура описывает, как взаимодействуют между собой 
клиент (в нашем случае фронтенд) и сервер (бэкенд).

4.1 Клиент - Роль клиента для СЕРВЕРА в том, чтобы сообщить серверу, что нужно сделать с данными,
которые хранятся в базе, или с данными, которые он передаёт.
Роль клиента для ПОЛЬЗОВАТЕЛЯ в том, чтобы представить данные в удобном виде и предоставить
механизмы для их обновления.
Для веба клиент почти всегда браузер.
4.2 Сервер - Сервер принимает запросы от клиента.
Его роль в том, чтобы сохранять информацию от клиента в базе данных, обрабатывать её
и предоставлять к ней доступ по некоторым правилам. Такие правила обычно называются бизнес-логикой.
На сервере помимо общения с клиентом могут запускаться какие-то фоновые задачи, например,
индексирование информации в базе данных для более быстрого поиска, или запуск автоматических email-рассылок.
4.3 База данных - База данных (БД) — это хранилище всей пользовательской и служебной информации.
Её роль в том, чтобы обеспечивать быстрый и бесперебойный доступ к этой информации и собственно хранение.

5. AJAX (Asynchronous JavaScript and XML) — общение между клиентом и сервером без перезагрузки страницы.

6. Работа современного веб-приложения:
1. Клиент делает первичный запрос на сервер.
2. Сервер отвечает HTML-страницей, иногда с набором каких-то данных внедрённых в виде JS-объекта 
в конце страницы.
2.1 Страница может быть либо отрисована на сервере и тогда клиенту придёт готовый HTML.
2.2 Либо отрисовкой будет заниматься сам клиент с помощью какой-нибудь библиотеки, например, React.
В этом случае от сервера приходит просто набор необходимых данных.
3. Пользователь совершает какое-то действие, например, просит отсортировать таблицу.
4. Клиент в ответ на это действие решает, какой запрос отправить на сервер, строит этот запрос и отправляет его.
5. Сервер принимает этот запрос, обрабатывает его и отправляет на клиент порцию новых данных.
6. Клиент принимает данные и перерисовывает часть страницы по ним сам.
То есть он уже не заменяет один кусок разметки другим готовым, а рисует разметку сам.

** https://itelon.ru/blog/arkhitektura-klient-server/

1. Одноуровневая архитектура (1-Tier)
Одноуровневая архитектура «клиент-сервер» (1-Tier) – такая, где все прикладные программы
рассредоточены по рабочим станциям, которые обращаются к общему серверу баз данных или к общему файловому серверу. 
Никаких прикладных программ сервер при этом не исполняет, только предоставляет данные.

2. Двухуровневая архитектура (2-Tier)
К двухуровневой архитектуре «клиент-сервер» следует относить такую, в которой прикладные программы сосредоточены
на сервере приложений (Application Server), например, сервере 1С или сервере CRM, а в рабочих станциях находятся
программы-клиенты, которые предоставляют для пользователей интерфейс для работы с приложениями на общем сервере.
2.1 Два варианта двухуровневой архитектуры:
1. Когда общие данные хранятся на сервере, а логика их обработки и бизнес-данные хранятся на клиентской машине,
то такая архитектура носит название “fat client thin server” (толстый клиент, тонкий сервер). 
2. Когда не только данные, но и логика их обработки и бизнес-данные хранятся на сервере, то это называется 
“thin client fat server” (тонкий клиент, толстый сервер). Такая архитектура послужила прообразом облачных
вычислений (Cloud Computing).

3. Трёхуровневая архитектура (3-Tier)
В трёхуровневой архитектуре сервер баз данных, файловый сервер и другие представляют собой отдельный уровень,
результаты работы которого использует сервер приложений. Логика данных и бизнес-логика находятся в сервере приложений.
Все обращения клиентов к базе данных происходят через промежуточное программное обеспечение (middleware),
которое находится на сервере приложений. Вследствие этого, повышается гибкость работы и производительность.

4. Многоуровневая архитектура (N-Tier)
В отдельный класс архитектуры «клиент-сервер» можно вынести многоуровневую архитектуру, 
в которой несколько серверов приложений используют результаты работы друг друга,
а также данные от различных серверов баз данных, файловых серверов и других видов серверов.
По сути, предыдущий вариант, трёхуровневая архитектура – не более, чем частный случай многоуровневой архитектуры.

5. Характеристики архитектуры «клиент-сервер»
1. Асимметричность протоколов. Между клиентами и сервером существуют отношения «один ко многим».
Инициатором диалога с сервером обычно является клиент.
2. Инкапсуляция услуг. После получения запроса на услугу от клиента, сервер решает, как должна быть выполнена данная услуга.
Модификация («апгрейд») сервера может производиться без влияния на работу клиентов, поскольку это не влияет
на опубликованный интерфейс взаимодействия между ними. Иными словами, максимум, что может при этом
почувствовать пользователь – незначительная задержка отклика сервера в течение небольшого времени апгрейда.
3. Целостность. Программы и общие данные для сервера управляются централизованно, что снижает стоимость обслуживания
и защищает целостность данных. В то же время, данные клиентов остаются персонифицированными и независимыми.
4. Местная прозрачность. Сервер – это программный процесс, который может исполняться на той же машине, что и клиент,
либо на другой машине, подключенной по сети. Программное обеспечение «клиент-сервер»
обычно скрывает местоположение сервера от клиентов, перенаправляя запрос на услуги через сеть.
5. Обмен на основе сообщений. Клиенты и сервер являются нежёстко связанными («loosely-coupled») процессами,
которые обмениваются сообщениями: запросами на услуги и ответами на них.
6. Модульный дизайн, способный к расширению. Модульный дизайн программной платформы «клиент-сервер»
придаёт ей устойчивость к отказам, то есть, отказ в каком-то модуле не вызывает отказа всего приложения.
В такой системе, один или больше серверов могут отказать без остановки всей системы в целом, до тех пор,
пока услуги отказавшего сервера могут быть предоставлены с резервного сервера.
Другое преимущество модульности в том, что приложение «клиент-сервер» может автоматически реагировать на повышение
или понижение нагрузки на систему, путём добавления или отключения услуг или серверов.
7. Независимость от платформы. Идеальное приложение «клиент-сервер» не зависит от платформ оборудования или операционной системы.
Клиенты и серверы могут развёртываться на различных аппаратных платформах и разных операционных системах.
8. Масштабируемость. Системы «клиент-сервер» могут масштабироваться как горизонтально (по числу серверов и клиентов),
так и вертикально (по производительности и спектру услуг).
9. Разделение функционала. Система «клиент-сервер» — это соотношение между процессами, работающими на одной или на разных машинах.
Сервер – это процесс предоставления услуг. Клиент – это потребитель услуг.
10. Общее использование ресурсов. Один сервер может предоставлять услуги множеству клиентов одновременно,
и регулировать их доступ к совместно используемым ресурсам.

** https://www.4stud.info/networking/lecture5.html

В рамках многоуровневого представления вычислительных систем можно выделить три группы функций,
ориентированных на решение различных подзадач:
1. функции ввода и отображения данных (обеспечивают взаимодействие с пользователем);
компонент представления отвечает за пользовательский интерфейс;
2. прикладные функции, характерные для данной предметной области;
прикладной компонент реализует алгоритм решения конкретной задачи;
3. функции управления ресурсами (файловой системой, базой даных и т.д.)
компонент управления ресурсом обеспечивает доступ к необходимым ресурсам.

Архитектура «клиент-сервер» определяет общие принципы организации взаимодействия в сети, где имеются серверы,
узлы-поставщики некоторых специфичных функций (сервисов) и клиенты, потребители этих функций.
Практические реализации такой архитектуры называются клиент-серверными технологиями.
Каждая технология определяет собственные или использует имеющиеся правила взаимодейстия
между клиентом и сервером, которые называются протоколом обмена (протоколом взаимодействия).

Двухзвенная архитектура
Двухзвенной (two-tier, 2-tier) она называется из-за необходимости распределения трех базовых компонентов
между двумя узлами (клиентом и сервером).
Двухзвенная архитектура используется в клиент-серверных системах, где сервер отвечает на клиентские запросы напрямую
и в полном объеме, при этом используя только собственные ресурсы. Т.е. сервер не вызывает сторонние сетевые приложения
и не обращается к сторонним ресурсам для выполнения какой-либо части запроса

Трехзвенная архитектура
Они реализуются на основе модели сервера приложений, где сетевое приложение разделено на две и более частей,
каждая из которых может выполняться на отдельном компьютере. Выделенные части приложения взаимодействуют друг с другом,
обмениваясь сообщениями в заранее согласованном формате.
В этом случае двухзвенная клиент-серверная архитектура становится трехзвенной (three-tier, 3-tier).
Как правило, третьим звеном в трехзвенной архитектуре становится сервер приложений, компоненты распределяются следующим образом:
Представление данных — на стороне клиента.
Прикладной компонент — на выделенном сервере приложений (как вариант, выполняющем функции промежуточного ПО).
Управление ресурсами — на сервере БД, который и представляет запрашиваемые данные.
Трехзвенная архитектура может быть расширена до многозвенной (N-tier, Multi-tier) путем выделения дополнительных серверов,
каждый из которых будет представлять собственные сервисы и пользоваться услугами прочих серверов разного уровня.

Сравнение архитектур
Двухзвенная архитектура проще, так как все запросы обслуживаются одним сервером,
но именно из-за этого она менее надежна и предъявляет повышенные требования к производительности сервера.
Трехзвенная архитектура сложнее, но благодаря тому, что функции распределены между
серверами второго и третьего уровня, эта архитектура представляет:
Высокую степень гибкости и масштабируемости.
Высокую безопасность (т.к. защиту можно определить для каждого сервиса или уровня).
Высокую производительность (т.к. задачи распределены между серверами).