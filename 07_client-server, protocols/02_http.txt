** https://zametkinapolyah.ru/servera-i-protokoly/navigaciya-po-rubrike-http-protokol.html

1. HTTP протокол: определение и принципы работы
1.1 HTTP (HyperText Transfer Protocol) – это протокол седьмого уровня модели OSI для передачи данных,
в основе которого лежит архитектура взаимодействие клиент-сервер.
Поскольку в основе протокола лежит взаимодействие клиент-сервер, то предполагается, что есть клиент,
который делает HTTP запросы и есть HTTP сервер, который обрабатывает эти запросы и дает клиенту HTTP ответы.
Все ответы сервера содержат коды состояния, а все запросы клиента имеют HTTP методы.
Протокол HTTP довольно строгий и требует от приложений (протокол HTTP позволяет идентифицировать приложения)
как клиентских, так и серверных строго исполнения стандарта.

1.2 Типичные задачи, которые решает HTTP протокол: протокол HTTP осуществляет доступ к веб-ресурсам
и обмен данными между пользовательскими приложениями. По сути HTTP протокол обеспечивает работу интернета.
Иногда HTTP протокол используется как транспорт для других протоколов
(при помощи HTTP протокола передается информация для других протоколов): SOAP, XML-RPC и другие.
Передача данных по HTTP протоколу осуществляется через TCP/IP соединение
(вы можете прочитать более подробно про HTTP соединение и обсуждение в HTTP).
Машина, которая выступает в роли сервера использует восьмидесятый TCP порт или порт 8080.
Клиентские приложения, которые используют HTTP протокол обычно настроены
на использование 80-го порта для соединения с HTTP сервером.
HTTP протокол не имеет инструментов для шифрования данных при передаче,
но для него есть расширяющие протоколы: SSL и TLS. 

1.3 HTTP сервер или веб-сервер – это программа, которая понимает, что нужно клиенту и выдает ему ответы
в виде HTML страниц, на которых может содержаться различная информация: изображения, тексты, скрипты, файлы,
медиа данные (видео и аудио) и многое другое. HTTP сервер принимает HTTP запрос от клиента
и дает ему HTTP ответ, хочу обратить ваше внимание на то, что в нагрузку к HTTP ответу не обязательно должен
идти ответ в виде HTML страницы, данные могут быть и другими.
Понятие веб-сервер намного более широкое, чем сервер HTTP. Веб-сервер – это программный комплекс, необходимый
для поддержания работы веб-протоколов и непосредственно железо, на котором эти программы работают. 
HTTP сервер – это всего лишь одна программа, реализующая взаимодействие по протоколу HTTP. 

1.4 Обязательные требования содержания: версию HTTP протокола, которая указывается в первой строке,
поле HTTP заголовка Host, HTTP объект от заголовка должен быть отделен пустой строкой, 
любое HTTP сообщение начинается со статусной строки, любой HTTP запрос должен содержать HTTP метод,
а любой HTTP ответ в первой строке должен отсылать клиенту код состояния.

1.5 Термины http:
● HTTP соединение (HTTP connection). Виртуальный канал транспортого уровня модели сетевого взаимодействия OSI,
установленный между двумя программами с целью связи.
● Сообщение HTTP (message HTTP). Основной модуль HTTP связи, состоящей из структурной последовательности
октетов (байтов), соответствующих синтаксису HTTP и передаваемых по соединению.
● HTTP запрос (HTTP request). Любое HTTP сообщение, содержащее запрос, запрос можно определить по наличию
HTTP метода. Запрос отправляет клиентское приложение с целью получения услуги от сервера.
● HTTP ответ (response) любое HTTP сообщение, содержащее ответ в форме, удовлетворяющей стандарт HTTP,
ответ можно определить по наличию кода состояния. Ответы посылают серверные приложения, например,
веб-сервер Apache, ответы содержат служебную информацию, по которой клиент вид, как сервер понял запрос,
а также в ответе может присутствовать объект, в котором содержится полезная для человека информация.
● HTTP ресурс (HTTP resource). Сетевой объект данных или сервис, который может быть идентифицирован URI
(более подробно смотри запись URI в HTTP). Ресурсы могут быть доступны в нескольких представлениях 
(например на нескольких языках, в разных форматах данных, иметь различный размер, иметь различную
разрешающую способность) или различаться по другим параметрам.
● HTTP объект (HTTP entity). Информация, передаваемая в качестве полезной нагрузки запроса или ответа. 
Объект состоит из метаинформации в форме полей заголовка объекта и содержания в форме тела объекта.
● HTTP представление (HTTP representation). Объект включенный в ответ, и подчиняющийся обсуждению содержимого
(Content Negotiation). Может существовать несколько представлений, связанных со специфическими состояниями ответа.
● Обсуждение содержимого (content negotiation). Механизм для выбора соответствующего представления во время
обслуживания запроса. Представление объектов в любом ответе может быть обсуждено (включая ошибочные ответы).
В процессе обсуждения клиент и сервер договариваются о том, как и в каком виде они будут обмениваться информацией
друг с другом вплоть до версии HTTP протокола, которая будет использована для обмена.
● HTTP вариант (HTTP variant). Ресурс может иметь одно, или несколько представлений, связанных с ним
в данный момент. Каждое из этих представлений называется «вариант». Использование термина «вариант» 
не обязательно подразумевает, что ресурс подчинен обсуждению содержимого.
● HTTP клиент (HTTP client) программа, которая устанавливает соединения с целью посылки запросов.
● HTTP Агент пользователя (HTTP user agent). Клиент, который инициирует запрос. Как правило браузеры, редакторы,
роботы (spiders), или другие инструментальные средства пользователя.
● HTTP сервер (HTTP server). Приложение, которое слушает соединения, принимает запросы на обслуживание
и посылает ответы. Любая такая программа способна быть как клиентом, так и сервером;
наше использование данного термина относится скорее к роли, которую программа выполняет,
создавая специфические соединения, нежели к возможностям программы вообще. 
Аналогично, любой сервер может действовать как первоначальный сервер, прокси-сервер, шлюз,
или туннель (tunnel), изменяя поведение, основываясь на характере каждого запроса.
● Первоначальный сервер HTTP (origin server HTTP). Сервер, на котором данный ресурс постоянно находится
или должен быть создан.
● Прокси-сервер (proxy server HTTP). Программа-посредник, которая действует и как сервер, и как клиент
с целью создания запросов от имени других клиентов. Запросы обслуживаются прокси-сервером, или передаются им,
возможно с изменениями. Прокси-сервер должен удовлетворять требованиям клиента и сервера, согласно этой спецификации.
● Шлюз (gateway). Сервер, который действует как посредник для некоторого другого сервера. 
В отличие от прокси-сервера, шлюз получает запросы в качестве первоначального сервера для запрошенного ресурса;
клиент запроса может не знать, что он соединяется со шлюзом.
● Туннель (tunnel). Программа-посредник, которая поддерживает соединение. Один раз созданный, туннель
не рассматривается как часть HTTP связи, хотя туннель, возможно, был инициализирован запросом HTTP.
Туннель прекращает существовать, когда оба конца соединения закрываются.
● Кэш (cache). Локальная память, в которой программа хранит сообщения ответов, и в которой располагается подсистема,
управляющая хранением, поиском и стиранием сообщений. Кэш сохраняет ответы, которые могут быть сохранены,
чтобы уменьшить время ответа и загрузку сети (траффик) при будущих эквивалентных запросах.
Любой клиент или сервер может иметь кэш, но кэш не может использоваться сервером, который действует как туннель.
● Кэшируемый (cachable). Ответ является кэшируемым, если кэшу разрешено сохранить копию ответного сообщения
для использования при ответе на последующие запросы. Даже если ресурс кэшируем, могут существовать
дополнительные ограничения на использование кэшем сохраненной копии для сходного запроса.
● Непосредственный (first-hand). Ответ считается непосредственным,
если он приходит непосредственно от первоначального сервера без ненужной задержки,
возможно через один или несколько прокси-серверов. Ответ также является непосредственным,
если его правильность только что была проверена непосредственно первоначальным сервером.
● Точное время устаревания (explicit expiration time). Время, определенное первоначальным сервером
и показывающее кэшу, когда объект больше не может быть возвращен кэшем клиенту
без дополнительной проверки правильности.
● Эвристическое время устаревания (heuristic expiration time).
Время устаревания, назначенное кэшем, если не указано точное время устаревания.
● Возраст (age). Возраст ответа — время, прошедшее с момента отсылки,
или успешной проверки ответа первоначальным сервером.
● Время жизни (freshness lifetime). Отрезок времени между порождением ответа и временем устаревания.
● Свежий (fresh). Ответ считается свежим, если его возраст еще не превысил время жизни.
● Просроченнный (stale). Ответ считается просроченным, если его возраст превысил время жизни.
● Семантически прозрачный (semantically transparent). Говорят, что кэш ведет себя «семантически прозрачным»
образом в отношении специфического ответа, когда использование кэша не влияет ни на клиента запроса,
ни на первоначальный сервер, но повышает эффективность. Когда кэш семантически прозрачен, клиент получает
точно такой же ответ (за исключением промежуточных (hop-by-hop) заголовков),
который получил бы, запрашивая непосредственно первоначальный сервер, а не кэш.
● Указатель правильности (validator). Элемент протокола (например, метка объекта или время
последней модификации (Last-Modified time)), который используется, чтобы выяснить,
является ли находящаяся в кэше копия эквивалентом объекта.

2. Параметры HTTP протокола. HTTP протокол обладает параметрами, которые должны передаваться в HTTP сообщениях,
параметры, которые следует передавать и опциональными параметрами. HTTP параметры указывают клиентам и серверам
общие правила на обработку сообщений, другими словами HTTP параметры определяют общий принцип работы этих программ.
HTTP параметры могут характеризовать то, как должна обрабатываться служебная информация и то,
как, в каком виде и количестве данные должны быть представлены конечному пользователю.

● HTTP параметр, отвечающий за версию протокола HTTP.
HTTP протокол для указания версии использует нумерацию типа: мажорная.минорная. Первое, что должен указать
клиент серверу при установке соединения по HTTP – это версия HTTP, которой они будут пользоваться для общения.
В каждой версии HTTP есть свои особенности и тонкости. В рамках данных заметок мы будем изучать HTTP 1.1.
Когда разработчики стандарта HTTP меняют или расширяют семантику HTTP протокола, тогда они изменяют минорную
версию HTTP. Когда меняется алгоритм анализа HTTP сообщений или, когда изменяется формат сообщений,
то меняется мажорная версия HTTP протокола.

● HTTP параметр, определяющий ресурс (URI).
Еще одним параметром в HTTP является URI ресурса, к которому клиент делает HTTP запрос. В качестве URI может
выступать URL, в этом случае у нас есть еще и информация о местонахождение ресурса или URN,
который идентифицирует ресурс, но никак не определяет его местонахождение. URI в HTTP это обычная строка,
которая записывается в определенном формате, еще мы можем сказать, что URI в HTTP может быть представлен
в двух формах: абсолютной и относительной. Абсолютная форма URI в HTTP начинается с имени схемы.

● HTTP параметр даты и времени.
Дата и время в SQLite3 может храниться с классом данных TEXT, REAL и INTEGER, 
для каждого из этих классов есть определенный формат записи даты и времени

● HTTP параметры, отвечающие за кодирование.
Кодовые таблицы в HTTP используются для того, чтобы преобразовывать последовательность байт в последовательность
символов, понятных человеку. Для таких манипуляций в HTTP может применяться несколько кодовых таблиц. 

3. HTTP сообщение. 
HTTP сообщение – это способ общения между клиентом и сервером по средствам HTTP протокола. 
Соответственно, HTTP сообщения делятся на два вида: HTTP сообщения запросы,
которые посылает клиент и HTTP сообщения ответы, которые посылает сервер HTTP.
Общая структура HTTP сообщений выглядит следующим образом:
Начальная строка сообщения.
Заголовок, который может содержать одно или несколько полей заголовка.
Пустая строка (на самом деле эта строка не пустая, она содержит символ CTRLF), которая обозначает конец заголовка.
Необязательное тело сообщения или HTTP объект.

3.1 Заголовки HTTP сообщений
Сразу стоить отметить, что все HTTP заголовки имеют одинаковый формат. Общие заголовки, заголовки ответов и запросов,
заголовки объектов у всех у них единый и обобщенный формат. Любое поле заголовка в HTTP сообщение имеет
единый синтаксис: имя_заголовка : значение. 
Область применения заголовков в HTTP сообщениях:
● общие заголовки – общие заголовки получили своё название из-за того, что используются
и HTTP сообщениях запросов и в HTTP сообщениях ответов;
● заголовки запросов – получили свое название из-за того, что используются в HTTP сообщениях ответов;
● заголовки ответов – их так назвали потому что применяются для HTTP сообщений ответов;
● заголовки объектов – служат в HTTP сообщениях для передачи служебной (мета) информации о теле объекта,
если тела нет, то в них содержится информация о ресурсе, указанном, как URI (URI в HTTP).

3.2 Тело HTTP сообщений
Тело HTTP сообщения необязательная составляющая HTTP сообщения.
Тело HTTP сообщения используется для передачи тела объекта запроса или тела объекта ответа. 
Между телом объекта и телом HTTP сообщения есть разница только в том случае, когда используется кодирование передачи,
кодирование передачи указывается специальным полем Transfer-Encoding. 
Данное поле является частью HTTP сообщения, а не передаваемого объекта, поэтому его  может удалить любая
из общающихся сторон. Присутствие тела HTTP сообщения обозначается заголовками Content-Length и Transfer-Encoding.

3.3 HTTP запрос
HTTP запрос – это HTTP сообщение, которое клиент посылает HTTP серверу. Обычно HTTP запрос содержит:
Строку запроса, в которой указывается версия HTTP протокола и HTTP метод запроса;
Ноль или несколько заголовков, разделенных между собой символом конца строки, 
В которых передаются другие HTTP праметры для успешного HTTP соединения;
пустую строку, чтобы отделить служебную информацию от тела сообщения;
необязательное тело сообщения.
Метод HTTP запроса указывает серверу, как нужно обращаться к запрашиваемому ресурсу, который указан в URI.
Метод HTTP запроса чувствителен к регистру и его имя следует указывать только в верхнем регистре.

3.3.1 HTTP Метод
● Безопасные HTTP методы (Safe method HTTP)
Метод HTTP является безопасным, если он не меняет состояние сервера. Другими словами, безопасный метод проводит
операции "только чтение" (read-only). Несколько следующих методов HTTP безопасные: GET, HEAD или OPTIONS. 
Все безопасные методы являются также идемпотентными, как и некоторые другие, но при этом небезопасные,
такие как PUT или DELETE.
● Идемпотентный метод
Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд,
имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь
никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций.
Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны, но не метод POST.
Также все безопасные методы являются идемпотентными.
Методы:
● CONNECT
HTTP CONNECT method запускает двустороннюю связь с запрошенным ресурсом. 
Метод можно использовать для открытия туннеля.
К примеру, метод CONNECT может использоваться для доступа к сайту, который использует SSL(HTTPS).
Клиент запрашивает HTTP-прокси-сервер для туннелирования TCP-соединения с желаемым назначением.
За тем сервер переходит к подключению от имени клиента. После того, как соединение установлено сервером,
прокси-сервер продолжает проксировать поток TCP к клиенту и от него.
● DELETE
Метод запроса HTTP DELETE удаляет указанный ресурс.
● GET
HTTP-метод GET запрашивает представление указанного ресурса. GET-запросы должны только получать данные.
● HEAD
HTTP-метод HEAD запрашивает заголовки, идентичные тем, что возвращаются, если указанный ресурс будет запрошен
с помощью HTTP-метода GET. Такой запрос может быть выполнен перед загрузкой большого ресурса,
например, для экономии пропускной способности.
Ответ на метод HEAD не должен содержать тело. Если это не так, то его следует игнорировать. 
Но даже в этом случае заголовки сущности, описывающие содержимое тела, например Content-Length, 
должны быть включены в ответ. Они не относятся к телу ответа на запрос HEAD, которое должно быть пустым,
они относятся к телу ответа, полученный на аналогичный запрос с помощью метода GET.
● OPTIONS
HTTP-метод OPTIONS используется для описания параметров соединения с целевым ресурсом.
Клиент может указать особый URL для обработки метода OPTIONS, или * (звёздочку) чтобы указать весь сервер целиком.
Определение разрешённых сервером методов запроса
● PATCH
Метод запроса HTTP PATCH частично изменяет ресурс.
PATCH может как быть идемпотентным, так и не быть, в отличие от PUT, который всегда идемпотентен.
Операция считается идемпотентной, если её многократное выполнение приводит к тому же результату,
что и однократное выполнение. Например, если автоинкрементное поле является важной частью ресурса,
то PUT перезапишет его (т.к. он перезаписывает всё), но PATCH может и не перезаписать.
● POST
HTTP-метод POST предназначен для отправки данных на сервер. Тип тела запроса указывается в заголовке Content-Type.
Разница между PUT и POST состоит в том, что PUT является идемпотентным: повторное его применение даёт тот же
результат, что и при первом применении (то есть у метода нет побочных эффектов), тогда как повторный вызов одного
и того же метода POST может иметь такие эффекты, как например, оформление одного и того же заказа несколько раз.
● PUT
Метод запроса HTTP PUT создаёт новый ресурс или заменяет представление целевого ресурса,
данными представленными в теле запроса.
Разница между PUT и POST в том, что PUT является идемпотентным, т.е. единичный и множественные вызовы этого метода,
с идентичным набором данных, будут иметь тот же результат выполнения (без сторонних эффектов), в случае с POST,
множественный вызов с идентичным набором данных может повлечь за собой сторонние эффекты.
● TRACE
HTTP Метод TRACE выполняет проверку обратной связи по пути к целевому ресурсу, предоставляя полезный механизм отладки.

3.4 HTTP ответ
Структура HTTP ответа сервера состоит из:
Строки состояния HTTP ответа, в которой сервер указывает версию HTTP протокола и код состояния.
Нуля или нескольких полей HTTP заголовка, разделенных между собой символом CRLF.
Пустой строки (в этой строке должен быть только символ CRLF), эта строка обозначает окончание полей заголовка.
Необязательное тело HTTP сообщения.
● Status-Code – это целочисленный трехразрядный код результата понимания и удовлетворения запроса клиента.
Грубо говоря, это число, которое показывает то, как сервер понял запрос клиента. К коду состояния HTTP ответа
идет поясняющая фраз, которая предназначена для людей, чтобы те понимали, что в итоге случилось. 
Номер	Код состояния HTTP сервера и его описание
1xx: информационный код состояния HTTP сервера
Все коды состояний, начинающиеся с единицы говорят клиенту о том, что их запрос получен и находится в обработке 
и называются они — информационные коды состояния.
2xx: успешный код состояния HTTP сервера
Все коды состояний, начинающиеся с двойки говорят клиенту о том, что действие закончилось успешно:
получено, понято и обработано, такие коды называются успешные HTTP коды.
3xx: код перенаправления HTTP сервера
Все коды состояния, начинающиеся с тройки говорят клиенту о том, что для продолжения работы ему нужно
совершить какие-то действия, это коды получили название кодов перенаправления HTTP сервера.
4xx: коды ошибок HTTP клиента
Все коды состояния, начинающиеся с четверки говорят нам о том, что ошибка происходит по вине клиента
(неверный синтаксис, устаревший протокол и прочее), из-за чего сервер не может корректно отработать и дать ответ.
Их называют коды ошибок HTTP клиента.
5xx: коды ошибок HTTP сервера
Все коды состояний, начинающиеся с пятерки, говорят нам о том, что произошла ошибка на стороне сервера HTTP.
И они получили называние коды ошибок HTTP сервера.
● Поля заголовка HTTP ответа
Поля заголовка HTTP ответа необходимы серверу для того, чтобы передать дополнительную информацию клиенту,
которая не может быть помещена в строку состояния. Поля заголовка HTTP ответа помогают клиенту правильно
обработать HTTP сообщение сервера. Так же поля заголовка HTTP ответа могут содержать дополнительную
информацию о сервере и о дальнейшем доступе к ресурсу, указанному в URI

4. HTTP объекты
Объекты (HTTP Entity) могут передаваться вместе с сообщением в том случае, если иное не установлено методом
HTTP запроса или кодом состояния HTTP сервера. Структура объекта (HTTP Entity) очень проста:
поля заголовка объекта (HTTP entity-headers);
тело объекта (HTTP entity-body).
Тело HTTP объекта или HTTP entity-body, если оно присутствует в сообщении, имеет свой собственный формат
и способ кодирования (кодирование в HTTP), всё это определяется полями заголовка HTTP entity-header.
Тело объекта (HTTP entity-body) присутствует в сообщении только тогда, когда присутствует тело сообщения.
Тело объекта (HTTP entity-body) получается из тела сообщения путем декодирования передачи.

5. HTTP соединение
HTTP соединение или HTTP Connections на данный момент является постоянным для каждого URL (читай про URI в HTTP),
когда-то давно для каждого запроса клиента использовалось отдельное TCP соединение (даже если страница
просто обновлялась), что создавало большую нагрузку на машины с HTTP серверами, потому что каждый элемент страницы,
например изображение – это один или несколько запросов от клиента к серверу.
Постоянные HTTP соединения (HTTP Connections):
Сейчас не требуется постоянно поднимать новое TCP соединение для запроса, поэтому существенно
экономятся ресурсы серверов.
HTTP запросы клиента и ответы сервера можно представить как непрерывно работающий конвейер, причем параллельный,
в рамках одного TCP соединения.
Для установки TCP соединения машине клиента и машине сервера обязательно нужно посылать пакеты, следовательно,
третий уровень модели OSI был очень загружен, так было до появления постоянного HTTP соединения (HTTP Connections).
Поэтому на данный момент все HTTP клиенты и HTTP серверы разрабатываются с учетом того, чтобы работать,
используя постоянные HTTP соединения между клиентом и сервером. В версии протокола HTTP 1.1 любой клиент
по умолчанию считает, что ему нужно работать с сервером по постоянному HTTP соединению (Persistent Connection HTTP).
Как только клиент и сервер прекратили общаться, им необходимо разорвать TCP соединение,
делается это специальным полем в заголовке Connection
С учетом того, что HTTP соединение постоянное, клиент может посылать несколько HTTP запросов подряд,
не ожидаю HTTP сообщений от сервера, но сервер должен посылать HTTP ответы на сообщения клиента в том порядке,
в котором он получил запросы. С учетом того, что на данный момент используется постоянное
HTTP соединение (HTTP Connections), сервера имеют определенные значения времени ожидания
(конкретные цифры зависят непосредственно от настроек сервера),
после которого они перестают поддерживать неактивные соединения.

6. Аутентификация в HTTP. Проверка подлинности пользователей в HTTP
Аутентификация в HTTP довольно простая: для проверки подлинности используются, как всегда,
HTTP запросы от клиента и HTTP ответы от сервера, но со специальными полями заголовка. 
Для проверки подлинности у HTTP сервера есть специальный механизм, который по-русски называется вызов-ответ,
по-английски: challenge-response. Сервер может применить этот механизм чтобы вызвать (получить) от клиента HTTP
сообщение, в котором будут содержаться данные для аутентификации клиента.
Механизм вызов-ответ по сути – это набор полей HTTP заголовка и, как и любое другое поле, поля установления подлинности
в HTTP имеют атрибуты и значения, одно поле может иметь несколько значений,
которые разделяются запятой и не чувствительны к регистру символов.
Код 401 используется для «активации» механизма аутентификации в HTTP, этим кодом сервер просит клиента предоставить
данные для проверки подлинности HTTP. При этом HTTP ответ сервера должен содержать поле заголовка WWW-Authenticate.
Базовая схема аутентификации в HTTP реализована по принципу: логин-пароль. Клиент высылает серверу логин и пароль
для каждой области, к которой он желает получить доступ. После того, как сервер получил запрос к ресурсу,
указанному в URI, он может ответить клиенту вызовом
Грубо говоря, клиентское приложение отправляет серверу логин и пароль для данной области защиты,
а итоговое поле заголовка после кодирования

7. Механизм обсуждения в HTTP – это процесс, который позволяет выбрать наиболее удобное представление информации для человека.
Протокол HTTP имеет два вида обсуждения: обсуждение, управляемое сервером и обсуждение, управляемое клиентом.
Стоит отметить, что эти два вида обсуждения HTTP независимы друг от друга и могут использоваться вместе.

● Обсуждение, управляемое HTTP сервером
Обсуждение называется управляемым сервером в том случае, когда выбор наилучшего представления информации
для клиента определяется алгоритмами HTTP сервера. Выбор со стороны сервера определяется параметрами,
переданными клиентом: язык, способ кодирования содержимого и прочее, даже IP-адрес клиента может
повлиять на алгоритм сервера, не говоря уже о поле заголовка User-Agent. HTTP обсуждение управляемое
сервером наиболее эффективно, когда у клиента нет никакой информации о ресурсах HTTP сервера.
Клиент может помочь серверу выбрать наиболее удобный вариант при помощи полей заголовков:
Accept, Accept-Language, Accept-Encoding и других, важно, чтобы эти заголовки давали какие-то характеристики контента,
которые хочет получить клиент. Обычно для обсуждения содержимого HTTP сообщения клиента
не используют HTTP метод GET, поскольку он «тянет» с сервера объекты.
Можно привести и недостатки обсуждения, управляемого HTTP сервером:
Сервер никогда не может точно определить по HTTP запросу полные характеристики ответа, которые будут удобны пользователю.
Описывать полные возможности HTTP клиента при каждом запросе – не самое эффективное занятия, к тому же,
не самое безопасное для клиента, ведь протокол HTTP не имеет механизмов шифрования данных,
которое не стоит путать с кодированием содержимого, которое есть в HTTP.
Алгоритм обсуждения содержимого HTTP сервером может сильно его усложнить.
Механизм кэширования тоже усложняется, а иногда и ограничивается.
HTTP сервер при управлении обсуждения должен включать поле заголовка Vary, если ответ кэшируемый.

● Обсуждение, управляемое HTTP клиентом
Если обсуждение управляется HTTP клиентом, то наилучшее представление для пользователя выбирается клиентом.
Такое HTTP обсуждение основывается на полях заголовка, которые сервер отправляет клиенту при первом ответе.
Стоит обратить внимание на то, что HTTP сервер имеет разные URI (URI в HTTP) для разных представлений
одного и того же контента.
HTTP обсуждение, управляемое клиентом очень эффективно, когда ответы сервера изменяются в зависимости
от типичных параметров и характеристик, таких как: человеческий язык или способ кодирования информации. 
Но недостатком HTTP обсуждения, управляемого клиентом, является то, что для получения наиболее удобного
для пользователя контента необходим дополнительный запрос. Версия протокола HTTP 1.1 имеет следующие коды состояния
для управления содержимого на стороне клиента: код 301 (множественный выбор) и код 406 (не приемлем).

● Прозрачное обсуждение HTTP или комбинированное обсуждение
Прозрачное обсуждение HTTP или комбинированное обсуждение заключается в том, что наиболее удобное представление
информации для пользователя определяется сообща. Суть прозрачного обсуждения HTTP в наличии кэша.
По кэшу клиент определяет все доступные представления контента на сервере, но при этом сервер должен
понимать все характеристики, которые ему передает клиент в запросе.

8. Кэширование в HTTP: механизмы клиентского и серверного кэша в HTTP
Кэширование в HTTP реализовывалось для того, чтобы избавиться от необходимости отправлять лишние HTTP запросы от клиента,
а так же для того, чтобы сервер не отправлял HTTP ответы целиком так, как будто механизма кэширования нет вовсе.
Кэширование в протоколе HTTP управляется, как со стороны сервера, так и со стороны клиента,
это необходимо для более точного и удобного восприятия содержимого конечным пользователем.

Первое правило кэширования в HTTP заключается в том, что сервер должен посылать кэшированные HTTP ответы
с самой последней версией содержимого. При этом суть заключается в том, что клиент может получать данные
не с конечного HTTP сервера, а с ближайшего сервера, у которого в кэше есть информация о том, что содержится в
URI (URI в HTTP), который был указан в HTTP запросе, поэтому должны выполняться следующие правила:
● Проверка достоверности. Сервер, который дает ответ на запрос должен всегда быть в курсе
о содержимом конечного сервера, к которому идет обращение.
● Новизна кэша. Новизна кэша определяется конечным сервером.
● Предупреждение. Транзитный сервер должен предупреждать клиента о том, что его информация из кэша не самая «свежая».

В версии протокола HTTP 1.1 в качестве механизмов управления кэшированием используется поле заголовка Cache-Control.
Заголовок Cache-Control позволяет управлять HTTP кэшем, как клиенту, так и HTTP серверу при помощи директив,
которые они передают вместе с ответами и запросами. При этом директивы, передаваемые в поле заголовка Cache-Control,
отменяют значения по умолчанию для кэширования в HTTP. Необходимо отметить тот момент, что директивам заголовка
Cache-Control должны повиноваться все участники цепочки обмена данными между конечным сервером и клиентом.

Модель сравнения кэша в HTTP
HTTP протокол имеет модель сравнения кэша. Сравнение кэша в HTTP используется для того, чтобы клиент получал
всегда актуальную информацию. Когда сервер содержит информацию длительное время в кэше и хочет использовать
его как ответ на запрос клиента, то он сначала должен свериться с исходным сервером, чтобы понять:
действительно ли информация, хранимая в его кэше, будет актуальной для клиента. Для проверки актуальности кэша
могут быть использованы условные HTTP методы и условные поля HTTP заголовков, а так же специальные поля,
о которых мы поговорим ниже.
Например, клиент делает повторный запрос к HTTP серверу к тому же самому URI, при этом контент по данному URI
никак не изменился, сервер проанализировал всю эту информацию и вместо того, чтобы отправлять ответ
с телом сообщения (HTTP объектом), в котором может быть огромный HTML документ с таблицами стилей и скриптами,
сервер просто дает ответ с кодом состояния 304 (Not Modified), после чего браузер подтягивает страничку из кэша,
а конечный пользователь думает, что ему эта страница загрузилась с сервера из Австралии.

** https://developer.mozilla.org/ru/docs/Web/HTTP
1. HTTP сессия
Так как HTTP — это клиент-серверный протокол, HTTP сессия состоит из трёх фаз:
Клиент устанавливает TCP соединения (или другое соединение, если не используется TCP транспорт).
Клиент отправляет запрос и ждёт ответа.
Сервер обрабатывает запрос и посылает ответ, в котором содержится код статуса и соответствующие данные.
Начиная с версии HTTP/1.1, после третьей фазы соединение не закрывается, так как клиенту позволяется
инициировать другой запрос. То есть, вторая и третья фазы могут повторяться.
Так как HTTP это клиент-серверный протокол, соединение всегда устанавливается клиентом.
Открыть соединение в HTTP — значит установить соединение через соответствующий транспорт, обычно TCP.
В случае с TCP, в качестве порта HTTP сервера по умолчанию на компьютере используется порт 80,
хотя другие также часто используются, например 8000 или 8080. URL загружаемой страницы содержит
доменное имя и порт, который можно и не указывать если он соответствует порту по умолчанию.

2. HTTP-кеширование
Производительность веб-сайтов и приложений можно значительно повысить за счёт повторного использования
ранее полученных ресурсов. Веб-кеши сокращают задержку и снижают сетевой трафик, уменьшая тем самым время,
необходимое для отображения ресурсов. Используя HTTP-кеширование, сайты становятся более отзывчивыми.

2.1 Различные виды кеширования
Техника кеширования заключается в сохранении копии полученного ресурса для возврата этой копии в ответ
на дальнейшие запросы. Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения
к исходному серверу выполняется загрузка копии из кеша. Таким образом снижается нагрузка на сервер,
которому не приходится самому обслуживать всех клиентов, и повышается производительность — кеш ближе
к клиенту и ресурс передаётся быстрее. Кеширование является основным источником повышения производительност
веб-сайтов. Однако, кеш надо правильно сконфигурировать: ресурсы редко остаются неизменными,
так что копию требуется хранить только до того момента, как ресурс изменился, но не дольше.
Существует несколько видов кешей, которые можно разделить на две основные категории: приватные кеши
и кеши совместного использования. В кешах совместного использования (shared cache) хранятся копии,
которые могут направляться разным пользователям. Приватный кеш (private cache) предназначен для отдельного
пользователя. Здесь будет говориться в основном о кешах браузеров и прокси, но существуют также кеши шлюзов,
CDN, реверсные прокси кеши и балансировщики нагрузки, разворачиваемые на серверах для повышения надёжности,
производительности и масштабируемости веб-сайтов и веб-приложений.
● Приватный (private) кеш браузера
Приватный кеш предназначен для отдельного пользователя. Вы, возможно, уже видели параметры кеширования в настройках
своего браузера. Кеш браузера содержит все документы, загруженные пользователем по HTTP. Он используется для доступа
к ранее загруженным страницам при навигации назад/вперёд, позволяет сохранять страницы, или просматривать их код,
не обращаясь лишний раз к серверу. Кроме того, кеш полезен при отключении от сети.
● Общий (shared) прокси-кеш
Кеш совместного использования — это кеш, который сохраняет ответы, чтобы их потом могли использовать разные пользователи.
Например, в локальной сети вашего провайдера или компании, может быть установлен прокси, обслуживающий множество
пользователей, чтобы можно было повторно использовать популярные ресурсы, сокращая тем самым сетевой трафик и время ожидания.

2.2 Управление кешированием
Заголовок Cache-control
Поле Cache-Control общего заголовка HTTP/1.1 используется для задания инструкций по механизму кеширования как в запросах,
так и в ответах. Применяется для задания политик кеширования.
● Полное отсутствие кеширования
В кеше не должно сохраняться ничего — ни по запросам клиента, ни по ответам сервера.
Запрос всегда отправляется на сервер, ответ всегда загружается полностью.
Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate
● Кешировать, но проверять актуальность
Перед тем, как выдать копию, кеш запрашивает исходный сервер на предмет актуальности ресурса.
Cache-Control: no-cache
Приватные (private) и общие (public) кеши
Директива "public" указывает, что ответ можно сохранять в любом кеше. Это бывает полезно, если возникает потребность
сохранить страницы с HTTP-аутентификацией, или такими кодами ответа, которые обычно не кешируются.
Директива же "private" указывает, что ответ предназначен отдельному пользователю и не должен храниться
в кеше совместного использования. В этом случае ответ может сохраняться приватным кешем браузера.
Cache-Control: private
Cache-Control: public
● Срок действия (Expiration)
Самой важной здесь является директива "max-age=<seconds>" — максимальное время, в течение которого ресурс считается "свежим".
В отличие от директивы Expires, она привязана к моменту запроса. К неизменяющимся файлам приложения обычно
можно применять "агрессивное" кеширование. Примером таких статических файлов могут быть изображения,
файлы стилей (CSS) или скриптов (JavaScript).
Cache-Control: max-age=31536000
Проверка актуальности
При использовании директивы "must-revalidate" кеш обязан проверять статус ресурсов с истёкшим сроком действия.
Те копии, что утратили актуальность, использоваться не должны. Подробнее об этом рассказано ниже, в разделе Валидация кеша.
Cache-Control: must-revalidate
● Свежесть сохранённой копии
Однажды попав в кеш, ресурс, теоретически, может храниться там вечно. Однако, поскольку объем хранилища конечен,
записи периодически приходится оттуда удалять. Этот процесс называют вытеснением данных из кеша (cache eviction).
Кроме того, ресурсы могут изменяться на сервере, поэтому кеш требуется обновлять. Поскольку HTTP является
клиент-серверным протоколом, сервера не могут сами обращаться к кешам и клиентам при изменении ресурса;
им необходимо договориться о сроке действия сохранённой копии. До его истечения ресурс считается свежим (fresh),
после — устаревшим (stale). Алгоритмы вытеснения отдают предпочтение "свежим" ресурсам. Тем не менее, копия ресурса
не удаляется из кеша сразу же по истечении её срока действия; при получении запроса на устаревший ресурс кеш передаёт
его дальше с заголовком If-None-Match (en-US) на случай, если копия все ещё актуальна. Если это так, сервер возвращает
заголовок 304 Not Modified («не изменялось»), а тело ресурса не посылает, экономя тем самым трафик.
● Валидация кеша
Валидация кеша запускается при нажатии пользователем кнопки перезагрузки. Кроме того, она может выполняться в ходе
обычного просмотра страниц, если кешированный ответ включает заголовок "Cache-control: must-revalidate".
Другим фактором являются настройки кеширования браузера — можно потребовать принудительной валидации
при каждой загрузке документа.
При истечении срока годности документа он либо проходит валидацию, либо повторно доставляется с сервера.
Валидация может выполняться только если на сервере реализован сильный валидатор или слабый валидатор.

3. HTTP-куки
HTTP cookie (web cookie, куки браузера) - это небольшой фрагмент данных, который сервер отправляет браузеру пользователя.
Браузер может сохранить этот фрагмент у себя и отправлять на сервер с каждым последующим запросом. Это, в частности,
позволяет узнать, с одного ли браузера пришли несколько запросов (например, для аутентификации пользователя).
С помощью кук можно сохранить любую информацию о состоянии, HTTP-протокол сам по себе этого делать не умеет.
Куки часто используются для:
Управления сеансом (логины, корзины для виртуальных покупок)
Персонализации (пользовательские предпочтения)
Трекинга (отслеживания поведения пользователей)
Создание куки
Получив HTTP-запрос, вместе с ответом сервер может отправить заголовок Set-Cookie. 
Куки обычно запоминаются браузером и посылаются в HTTP-заголовке Cookie (en-US) с каждым новым запросом
к одному и тому же серверу. Можно задать срок действия кук, а также срок их жизни, после которого куки
не будут отправляться. Также можно указать ограничения на путь и домен, то есть указать,
в течении какого времени и к какому сайту они будут отсылаться.
Сессионные cookie
Простой cookie, пример которого приведён выше, представляет собой сессионный cookie (session cookie)
- такие cookie удаляются при закрытии клиента, то есть существуют только на протяжении текущего сеанса,
поскольку атрибуты Expires или Max-Age для него не задаются. Однако, если в браузере включено автоматическое
восстановление сеанса, что случается очень часто, cookie сеанса может храниться постоянно,
как если бы браузер никогда не закрывался.
Постоянные cookies
Постоянные cookie (permanent cookies) удаляются не с закрытием клиента, а при наступлении определённой даты
(атрибут Expires) или после определённого интервала времени (атрибут Max-Age).
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
Secure ("безопасные") и HttpOnly куки
"Безопасные" (secure) куки отсылаются на сервер только тогда, когда запрос отправляется по протоколу SSL и HTTPS.
Однако важные данные никогда не следует передавать или хранить в куках, поскольку сам их механизм весьма уязвим
в отношении безопасности, а флаг secure никакого дополнительного шифрования или средств защиты не обеспечивает.
Начиная с Chrome 52 и Firefox 52, незащищённые сайты (http:) не могут создавать куки с флагом Secure.

** HTTPS и механизм работы защиты
HTTPS (от англ. HyperText Transfer Protocol Secure) – это безопасный протокол передачи данных, который поддерживает
шифрование посредством криптографических протоколов SSL и TLS, и является расширенной версией протокола HTTP.
HTTPS работает благодаря SSL/TLS-сертификату. SSL/TLS-сертификат ― это цифровая подпись сайта.
С её помощью подтверждается его подлинность. Перед тем как установить защищённое соединение, браузер запрашивает
этот документ и обращается к центру сертификации, чтобы подтвердить легальность документа. Если он действителен,
то браузер считает этот сайт безопасным и начинает обмен данными. Вот откуда взялась и что означает S в HTTPS.
Кроме подтверждения подлинности сайта, SSL-сертификат шифрует данные. После того как браузер убедился в подлинности сайта,
начинается обмен шифрами. Шифрование HTTPS происходит при помощи симметричного и асимметричного ключа. Вот что это значит:
● Асимметричный ключ — каждая сторона имеет два ключа: публичный и частный. Публичный ключ доступен любому.
Частный известен только владельцу. Если браузер хочет отправить сообщение, то он находит публичный ключ сервера,
шифрует сообщение и отправляет на сервер. Далее сервер расшифровывает полученное сообщение с помощью своего частного ключа.
Чтобы ответить пользователю, сервер делает те же самые действия: поиск публичного ключа собеседника, шифрование, отправка.
● Симметричный ключ — у обеих сторон есть один ключ, с помощью которого они передают данные. Между двумя сторонами
уже должен быть установлен первичный контакт, чтобы браузер и сервер знали, на каком языке общаться.
Чтобы установить HTTPS-соединение, браузеру и серверу надо договориться о симметричном ключе. Для этого сначала браузер
и сервер обмениваются асимметрично зашифрованными сообщениями, где указывают секретный ключ
и далее общаются при помощи симметричного шифрования.
● Шифрование. Информация передаётся в зашифрованном виде. Благодаря этому злоумышленники не могут украсть информацию,
которой обмениваются посетители сайта, а также отследить их действия на других страницах.
● Аутентификация. Посетители уверены, что переходят на официальный сайт компании, а не на дубликат, сделанный злоумышленником.
● Сохранение данных. Протокол фиксирует все изменения данных. Если злоумышленник всё-таки пытался взломать защиту,
об этом можно узнать из сохранённых данных.
Схема работы HTTPS
Протокол HTTPS предназначен для безопасного соединения. 
Схема:
1. Браузер пользователя просит предоставить SSL-сертификат.
2. Сайт на HTTPS отправляет сертификат.
3. Браузер проверяет подлинность сертификата в центре сертификации.
4. Браузер и сайт договариваются о симметричном ключе при помощи асимметричного шифрования.
5. Браузер и сайт передают зашифрованную информацию.

TLS:
Протокол обеспечивает услуги: приватности (сокрытие передаваемой информации), целостности (обнаружение изменений),
аутентификации (проверка авторства). Достигаются они за счет гибридного шифрования, то есть совместного использования
ассиметричного и симметричного шифрования.
Симметричное шифрование предполагает наличие общего ключа одновременно у отправителя и получателя, с помощью которого
происходит шифровка и дешифровка данных. Данный тип не требователен к ресурсам, однако существенно страдает безопасность
из-за опасности кражи ключа злоумышленником.
При использовании ассиметричного шифрования существует открытый ключ, который можно свободно распространять, и закрытый ключ,
который держится в секрете у одной из сторон. Этот тип работает медленно, относительно симметричного шифрования,
однако скомпрометировать закрытый ключ сложнее.
Чтобы решить проблему производительности (шифровать ассиметрично абсолютно все - сложно), в TLS используется гибридное шифрование:
общий ключ для симметричного шифрования данных передается от клиента серверу зашифрованным открытым ключом сервера, после этого
сервер может его расшифровать своим закрытым ключом и использовать для обмена данными с клиентом.
● Client Hello - клиент начинает общение с сервером отсылая информацию о предпочитаемой версии протокола TLS,
набора поддерживаемых шифров (Cipher Spec), и случайного простого числа (client random),
необходимого в дальнейшем для генерации общего ключа симметричного шифрования.
● Server Hello - сервер отвечает выбранной версией протокола и выбранным из предложенного набора шифром, которые будут
непосредственно использоваться, своим случайным простым числом (server random) и идентификатором сессии.
● Certificate - сервер отправляет свой сертификат, а клиент производит проверку подписи удостоверяющего центра,
проверку доверия к удостоверяющему центру, проверку указанного домена сайта с фактическим, срока действия,
проверяет не был ли сертификат отозван.
● Server Key Exchange - этот этап происходит не всегда, только если необходимы дополнительные данные для создания
симметричного ключа при выбранном алгоритме. Например, при обмене ключами RSA этот шаг пропускается и для обмена
общим ключ передается от клиента серверу зашифрованным открытым ключом сервера из его сертификата.
● Server Hello Done - сервер сообщает, что начальный этап установки соединения завершен
● Client Key Exchange -  На основании client random, server random и pre-master secret псевдослучайная функция выдает
симметричный ключ и ключ вычисления MAC. Клиент и сервер имеют все необходимое для начала обмена полезной информацией.
● Change Cipher Spec - клиент говорит серверу, что он готов перейти на защищенное соединение.
● Finished - клиент зашифровывает симметричным ключом первое сообщение с MAC.
● Change Cipher Spec - сервер проверяет сообщение Finished от клиента и отправляет в ответ свою готовность к защищенному соединению.
● Finished - аналогично клиенту, сервер отправляет тестовое зашифрованное сообщение
● После этого соединение считается установленным, и происходит передача полезной информации
● close_notify - служебное сообщение, которое одна сторона отправляет другой, как уведомление о том, что считает соединение разорванным
и не будет принимать больше сообщения. Другая сторона в ответ обязана послать аналогичное сообщение close_notify.

Двусторонний TLS
Двусторонний TLS или Two Way TLS или mutual TLS (mTLS) означает проверку сертификата клиента.
Сервер после своего сообщения Certificate посылает запрос сертификата клиента CertificateRequest.
Клиент в ответ отправляет Certificate, сервер производит проверку, аналогичную проверке сертификата сервера клиентом.
Далее настройка TLS происходит в описанном выше порядке.

Протокол SSL был реализован на application-уровне, непосредственно над TCP (Transmission Control Protocol),
что позволяет более высокоуровневым протоколам (таким как HTTP или протоколу электронной почты) работать без изменений.
Если SSL сконфигурирован корректно, то сторонний наблюдатель может узнать лишь параметры соединения
(например, тип используемого шифрования), а также частоту пересылки и примерное количество данных, но не может читать и изменять их.
Transport(TCP) - Session(TLS) - Application(HTTP)
Как уже говорилось, TLS был разработан для работы над TCP, однако для работы с протоколами дейтаграмм, такими как
UDP (User Datagram Protocol), была разработана специальная версия TLS, получившая название DTLS (Datagram Transport Layer Security).
Протокол TLS предназначен для предоставления трёх услуг всем приложениям, работающим над ним, а именно: шифрование,
аутентификацию и целостность. На практике, для обеспечения безопасности, как правило используются все три:
Шифрование – сокрытие информации, передаваемой от одного компьютера к другому;
Аутентификация – проверка авторства передаваемой информации;
Целостность – обнаружение подмены информации подделкой.

TLS Handshake
● Так как TLS работает над TCP, для начала между клиентом и сервером устанавливается TCP-соединение.
● После установки TCP, клиент посылает на сервер спецификацию в виде обычного текста
(а именно версию протокола, которую он хочет использовать, поддерживаемые методы шифрования, etc).
● Сервер утверждает версию используемого протокола, выбирает способ шифрования из предоставленного списка,
прикрепляет свой сертификат и отправляет ответ клиенту (при желании сервер может так же запросить клиентский сертификат).
● Версия протокола и способ шифрования на данном моменте считаются утверждёнными, клиент проверяет
присланный сертификат и инициирует либо RSA, либо обмен ключами по Диффи-Хеллману, в зависимости от установленных параметров.
● Сервер обрабатывает присланное клиентом сообщение, сверяет MAC, и отправляет клиенту
заключительное (‘Finished’) сообщение в зашифрованном виде.
● Клиент расшифровывает полученное сообщение, сверяет MAC, и если всё хорошо, то соединение считается
установленным и начинается обмен данными приложений.
Начиная с первой публичной версии протокола (SSL 2.0) сервер в рамках TLS Handshake (а именно первоначального сообщения ServerHello)
может сгенерировать и отправить 32-байтный идентификатор сессии. Естественно, в таком случае у сервера хранится кэш сгенерированных
идентификаторов и параметров сеанса для каждого клиента. В свою очередь клиент хранит у себя присланный идентификатор и включает его
(конечно, если он есть) в первоначальное сообщение ClientHello. Если и клиент, и сервер имеют идентичные идентификаторы сессии,
то установка общего соединения происходит по упрощённому алгоритму, показанному на рисунке.
Если нет, то требуется полная версия TLS Handshake.
