** https://zametkinapolyah.ru/servera-i-protokoly/navigaciya-po-rubrike-http-protokol.html

1. HTTP протокол: определение и принципы работы
1.1 HTTP (HyperText Transfer Protocol) – это протокол седьмого уровня модели OSI для передачи данных,
в основе которого лежит архитектура взаимодействие клиент-сервер.
Поскольку в основе протокола лежит взаимодействие клиент-сервер, то предполагается, что есть клиент,
который делает HTTP запросы и есть HTTP сервер, который обрабатывает эти запросы и дает клиенту HTTP ответы.
Все ответы сервера содержат коды состояния, а все запросы клиента имеют HTTP методы.
Протокол HTTP довольно строгий и требует от приложений (протокол HTTP позволяет идентифицировать приложения)
как клиентских, так и серверных строго исполнения стандарта.

1.2 Типичные задачи, которые решает HTTP протокол: протокол HTTP осуществляет доступ к веб-ресурсам
и обмен данными между пользовательскими приложениями. По сути HTTP протокол обеспечивает работу интернета.
Иногда HTTP протокол используется как транспорт для других протоколов
(при помощи HTTP протокола передается информация для других протоколов): SOAP, XML-RPC и другие.
Передача данных по HTTP протоколу осуществляется через TCP/IP соединение
(вы можете прочитать более подробно про HTTP соединение и обсуждение в HTTP).
Машина, которая выступает в роли сервера использует восьмидесятый TCP порт или порт 8080.
Клиентские приложения, которые используют HTTP протокол обычно настроены
на использование 80-го порта для соединения с HTTP сервером.
HTTP протокол не имеет инструментов для шифрования данных при передаче,
но для него есть расширяющие протоколы: SSL и TLS. 

1.3 HTTP сервер или веб-сервер – это программа, которая понимает, что нужно клиенту и выдает ему ответы
в виде HTML страниц, на которых может содержаться различная информация: изображения, тексты, скрипты, файлы,
медиа данные (видео и аудио) и многое другое. HTTP сервер принимает HTTP запрос от клиента
и дает ему HTTP ответ, хочу обратить ваше внимание на то, что в нагрузку к HTTP ответу не обязательно должен
идти ответ в виде HTML страницы, данные могут быть и другими.
Понятие веб-сервер намного более широкое, чем сервер HTTP. Веб-сервер – это программный комплекс, необходимый
для поддержания работы веб-протоколов и непосредственно железо, на котором эти программы работают. 
HTTP сервер – это всего лишь одна программа, реализующая взаимодействие по протоколу HTTP. 

1.4 Обязательные требования содержания: версию HTTP протокола, которая указывается в первой строке,
поле HTTP заголовка Host, HTTP объект от заголовка должен быть отделен пустой строкой, 
любое HTTP сообщение начинается со статусной строки, любой HTTP запрос должен содержать HTTP метод,
а любой HTTP ответ в первой строке должен отсылать клиенту код состояния.

1.5 Термины http:
● HTTP соединение (HTTP connection). Виртуальный канал транспортого уровня модели сетевого взаимодействия OSI,
установленный между двумя программами с целью связи.
● Сообщение HTTP (message HTTP). Основной модуль HTTP связи, состоящей из структурной последовательности
октетов (байтов), соответствующих синтаксису HTTP и передаваемых по соединению.
● HTTP запрос (HTTP request). Любое HTTP сообщение, содержащее запрос, запрос можно определить по наличию
HTTP метода. Запрос отправляет клиентское приложение с целью получения услуги от сервера.
● HTTP ответ (response) любое HTTP сообщение, содержащее ответ в форме, удовлетворяющей стандарт HTTP,
ответ можно определить по наличию кода состояния. Ответы посылают серверные приложения, например,
веб-сервер Apache, ответы содержат служебную информацию, по которой клиент вид, как сервер понял запрос,
а также в ответе может присутствовать объект, в котором содержится полезная для человека информация.
● HTTP ресурс (HTTP resource). Сетевой объект данных или сервис, который может быть идентифицирован URI
(более подробно смотри запись URI в HTTP). Ресурсы могут быть доступны в нескольких представлениях 
(например на нескольких языках, в разных форматах данных, иметь различный размер, иметь различную
разрешающую способность) или различаться по другим параметрам.
● HTTP объект (HTTP entity). Информация, передаваемая в качестве полезной нагрузки запроса или ответа. 
Объект состоит из метаинформации в форме полей заголовка объекта и содержания в форме тела объекта.
● HTTP представление (HTTP representation). Объект включенный в ответ, и подчиняющийся обсуждению содержимого
(Content Negotiation). Может существовать несколько представлений, связанных со специфическими состояниями ответа.
● Обсуждение содержимого (content negotiation). Механизм для выбора соответствующего представления во время
обслуживания запроса. Представление объектов в любом ответе может быть обсуждено (включая ошибочные ответы).
В процессе обсуждения клиент и сервер договариваются о том, как и в каком виде они будут обмениваться информацией
друг с другом вплоть до версии HTTP протокола, которая будет использована для обмена.
● HTTP вариант (HTTP variant). Ресурс может иметь одно, или несколько представлений, связанных с ним
в данный момент. Каждое из этих представлений называется «вариант». Использование термина «вариант» 
не обязательно подразумевает, что ресурс подчинен обсуждению содержимого.
● HTTP клиент (HTTP client) программа, которая устанавливает соединения с целью посылки запросов.
● HTTP Агент пользователя (HTTP user agent). Клиент, который инициирует запрос. Как правило браузеры, редакторы,
роботы (spiders), или другие инструментальные средства пользователя.
● HTTP сервер (HTTP server). Приложение, которое слушает соединения, принимает запросы на обслуживание
и посылает ответы. Любая такая программа способна быть как клиентом, так и сервером;
наше использование данного термина относится скорее к роли, которую программа выполняет,
создавая специфические соединения, нежели к возможностям программы вообще. 
Аналогично, любой сервер может действовать как первоначальный сервер, прокси-сервер, шлюз,
или туннель (tunnel), изменяя поведение, основываясь на характере каждого запроса.
● Первоначальный сервер HTTP (origin server HTTP). Сервер, на котором данный ресурс постоянно находится
или должен быть создан.
● Прокси-сервер (proxy server HTTP). Программа-посредник, которая действует и как сервер, и как клиент
с целью создания запросов от имени других клиентов. Запросы обслуживаются прокси-сервером, или передаются им,
возможно с изменениями. Прокси-сервер должен удовлетворять требованиям клиента и сервера, согласно этой спецификации.
● Шлюз (gateway). Сервер, который действует как посредник для некоторого другого сервера. 
В отличие от прокси-сервера, шлюз получает запросы в качестве первоначального сервера для запрошенного ресурса;
клиент запроса может не знать, что он соединяется со шлюзом.
● Туннель (tunnel). Программа-посредник, которая поддерживает соединение. Один раз созданный, туннель
не рассматривается как часть HTTP связи, хотя туннель, возможно, был инициализирован запросом HTTP.
Туннель прекращает существовать, когда оба конца соединения закрываются.
● Кэш (cache). Локальная память, в которой программа хранит сообщения ответов, и в которой располагается подсистема,
управляющая хранением, поиском и стиранием сообщений. Кэш сохраняет ответы, которые могут быть сохранены,
чтобы уменьшить время ответа и загрузку сети (траффик) при будущих эквивалентных запросах.
Любой клиент или сервер может иметь кэш, но кэш не может использоваться сервером, который действует как туннель.
● Кэшируемый (cachable). Ответ является кэшируемым, если кэшу разрешено сохранить копию ответного сообщения
для использования при ответе на последующие запросы. Даже если ресурс кэшируем, могут существовать
дополнительные ограничения на использование кэшем сохраненной копии для сходного запроса.
● Непосредственный (first-hand). Ответ считается непосредственным,
если он приходит непосредственно от первоначального сервера без ненужной задержки,
возможно через один или несколько прокси-серверов. Ответ также является непосредственным,
если его правильность только что была проверена непосредственно первоначальным сервером.
● Точное время устаревания (explicit expiration time). Время, определенное первоначальным сервером
и показывающее кэшу, когда объект больше не может быть возвращен кэшем клиенту
без дополнительной проверки правильности.
● Эвристическое время устаревания (heuristic expiration time).
Время устаревания, назначенное кэшем, если не указано точное время устаревания.
● Возраст (age). Возраст ответа — время, прошедшее с момента отсылки,
или успешной проверки ответа первоначальным сервером.
● Время жизни (freshness lifetime). Отрезок времени между порождением ответа и временем устаревания.
● Свежий (fresh). Ответ считается свежим, если его возраст еще не превысил время жизни.
● Просроченнный (stale). Ответ считается просроченным, если его возраст превысил время жизни.
● Семантически прозрачный (semantically transparent). Говорят, что кэш ведет себя «семантически прозрачным»
образом в отношении специфического ответа, когда использование кэша не влияет ни на клиента запроса,
ни на первоначальный сервер, но повышает эффективность. Когда кэш семантически прозрачен, клиент получает
точно такой же ответ (за исключением промежуточных (hop-by-hop) заголовков),
который получил бы, запрашивая непосредственно первоначальный сервер, а не кэш.
● Указатель правильности (validator). Элемент протокола (например, метка объекта или время
последней модификации (Last-Modified time)), который используется, чтобы выяснить,
является ли находящаяся в кэше копия эквивалентом объекта.

2. Параметры HTTP протокола. HTTP протокол обладает параметрами, которые должны передаваться в HTTP сообщениях,
параметры, которые следует передавать и опциональными параметрами. HTTP параметры указывают клиентам и серверам
общие правила на обработку сообщений, другими словами HTTP параметры определяют общий принцип работы этих программ.
HTTP параметры могут характеризовать то, как должна обрабатываться служебная информация и то,
как, в каком виде и количестве данные должны быть представлены конечному пользователю.

● HTTP параметр, отвечающий за версию протокола HTTP.
HTTP протокол для указания версии использует нумерацию типа: мажорная.минорная. Первое, что должен указать
клиент серверу при установке соединения по HTTP – это версия HTTP, которой они будут пользоваться для общения.
В каждой версии HTTP есть свои особенности и тонкости. В рамках данных заметок мы будем изучать HTTP 1.1.
Когда разработчики стандарта HTTP меняют или расширяют семантику HTTP протокола, тогда они изменяют минорную
версию HTTP. Когда меняется алгоритм анализа HTTP сообщений или, когда изменяется формат сообщений,
то меняется мажорная версия HTTP протокола.

● HTTP параметр, определяющий ресурс (URI).
Еще одним параметром в HTTP является URI ресурса, к которому клиент делает HTTP запрос. В качестве URI может
выступать URL, в этом случае у нас есть еще и информация о местонахождение ресурса или URN,
который идентифицирует ресурс, но никак не определяет его местонахождение. URI в HTTP это обычная строка,
которая записывается в определенном формате, еще мы можем сказать, что URI в HTTP может быть представлен
в двух формах: абсолютной и относительной. Абсолютная форма URI в HTTP начинается с имени схемы.

● HTTP параметр даты и времени.
Дата и время в SQLite3 может храниться с классом данных TEXT, REAL и INTEGER, 
для каждого из этих классов есть определенный формат записи даты и времени

● HTTP параметры, отвечающие за кодирование.
Кодовые таблицы в HTTP используются для того, чтобы преобразовывать последовательность байт в последовательность
символов, понятных человеку. Для таких манипуляций в HTTP может применяться несколько кодовых таблиц. 

3. HTTP сообщение. 
HTTP сообщение – это способ общения между клиентом и сервером по средствам HTTP протокола. 
Соответственно, HTTP сообщения делятся на два вида: HTTP сообщения запросы,
которые посылает клиент и HTTP сообщения ответы, которые посылает сервер HTTP.
Общая структура HTTP сообщений выглядит следующим образом:
Начальная строка сообщения.
Заголовок, который может содержать одно или несколько полей заголовка.
Пустая строка (на самом деле эта строка не пустая, она содержит символ CTRLF), которая обозначает конец заголовка.
Необязательное тело сообщения или HTTP объект.

3.1 Заголовки HTTP сообщений
Сразу стоить отметить, что все HTTP заголовки имеют одинаковый формат. Общие заголовки, заголовки ответов и запросов,
заголовки объектов у всех у них единый и обобщенный формат. Любое поле заголовка в HTTP сообщение имеет
единый синтаксис: имя_заголовка : значение. 
Область применения заголовков в HTTP сообщениях:
● общие заголовки – общие заголовки получили своё название из-за того, что используются
и HTTP сообщениях запросов и в HTTP сообщениях ответов;
● заголовки запросов – получили свое название из-за того, что используются в HTTP сообщениях ответов;
● заголовки ответов – их так назвали потому что применяются для HTTP сообщений ответов;
● заголовки объектов – служат в HTTP сообщениях для передачи служебной (мета) информации о теле объекта,
если тела нет, то в них содержится информация о ресурсе, указанном, как URI (URI в HTTP).

3.2 Тело HTTP сообщений
Тело HTTP сообщения необязательная составляющая HTTP сообщения.
Тело HTTP сообщения используется для передачи тела объекта запроса или тела объекта ответа. 
Между телом объекта и телом HTTP сообщения есть разница только в том случае, когда используется кодирование передачи,
кодирование передачи указывается специальным полем Transfer-Encoding. 
Данное поле является частью HTTP сообщения, а не передаваемого объекта, поэтому его  может удалить любая
из общающихся сторон. Присутствие тела HTTP сообщения обозначается заголовками Content-Length и Transfer-Encoding.

3.3 HTTP запрос
HTTP запрос – это HTTP сообщение, которое клиент посылает HTTP серверу. Обычно HTTP запрос содержит:
Строку запроса, в которой указывается версия HTTP протокола и HTTP метод запроса;
Ноль или несколько заголовков, разделенных между собой символом конца строки, 
В которых передаются другие HTTP праметры для успешного HTTP соединения;
пустую строку, чтобы отделить служебную информацию от тела сообщения;
необязательное тело сообщения.
Метод HTTP запроса указывает серверу, как нужно обращаться к запрашиваемому ресурсу, который указан в URI.
Метод HTTP запроса чувствителен к регистру и его имя следует указывать только в верхнем регистре.

3.3.1 HTTP Метод
● Безопасные HTTP методы (Safe method HTTP)
Метод HTTP является безопасным, если он не меняет состояние сервера. Другими словами, безопасный метод проводит
операции "только чтение" (read-only). Несколько следующих методов HTTP безопасные: GET, HEAD или OPTIONS. 
Все безопасные методы являются также идемпотентными, как и некоторые другие, но при этом небезопасные,
такие как PUT или DELETE.
● Идемпотентный метод
Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд,
имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь
никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций.
Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны, но не метод POST.
Также все безопасные методы являются идемпотентными.
● CONNECT
HTTP CONNECT method запускает двустороннюю связь с запрошенным ресурсом. 
Метод можно использовать для открытия туннеля.
К примеру, метод CONNECT может использоваться для доступа к сайту, который использует SSL(HTTPS).
Клиент запрашивает HTTP-прокси-сервер для туннелирования TCP-соединения с желаемым назначением.
За тем сервер переходит к подключению от имени клиента. После того, как соединение установлено сервером,
прокси-сервер продолжает проксировать поток TCP к клиенту и от него.
● DELETE
Метод запроса HTTP DELETE удаляет указанный ресурс.
● GET
HTTP-метод GET запрашивает представление указанного ресурса. GET-запросы должны только получать данные.
● HEAD
HTTP-метод HEAD запрашивает заголовки, идентичные тем, что возвращаются, если указанный ресурс будет запрошен
с помощью HTTP-метода GET. Такой запрос может быть выполнен перед загрузкой большого ресурса,
например, для экономии пропускной способности.
Ответ на метод HEAD не должен содержать тело. Если это не так, то его следует игнорировать. 
Но даже в этом случае заголовки сущности, описывающие содержимое тела, например Content-Length, 
должны быть включены в ответ. Они не относятся к телу ответа на запрос HEAD, которое должно быть пустым,
они относятся к телу ответа, полученный на аналогичный запрос с помощью метода GET.
● OPTIONS
HTTP-метод OPTIONS используется для описания параметров соединения с целевым ресурсом.
Клиент может указать особый URL для обработки метода OPTIONS, или * (звёздочку) чтобы указать весь сервер целиком.
Определение разрешённых сервером методов запроса
● PATCH
Метод запроса HTTP PATCH частично изменяет ресурс.
PATCH может как быть идемпотентным, так и не быть, в отличие от PUT, который всегда идемпотентен.
Операция считается идемпотентной, если её многократное выполнение приводит к тому же результату,
что и однократное выполнение. Например, если автоинкрементное поле является важной частью ресурса,
то PUT перезапишет его (т.к. он перезаписывает всё), но PATCH может и не перезаписать.
● POST
HTTP-метод POST предназначен для отправки данных на сервер. Тип тела запроса указывается в заголовке Content-Type.
Разница между PUT и POST состоит в том, что PUT является идемпотентным: повторное его применение даёт тот же
результат, что и при первом применении (то есть у метода нет побочных эффектов), тогда как повторный вызов одного
и того же метода POST может иметь такие эффекты, как например, оформление одного и того же заказа несколько раз.
● PUT
Метод запроса HTTP PUT создаёт новый ресурс или заменяет представление целевого ресурса,
данными представленными в теле запроса.
Разница между PUT и POST в том, что PUT является идемпотентным, т.е. единичный и множественные вызовы этого метода,
с идентичным набором данных, будут иметь тот же результат выполнения (без сторонних эффектов), в случае с POST,
множественный вызов с идентичным набором данных может повлечь за собой сторонние эффекты.
● TRACE
HTTP Метод TRACE выполняет проверку обратной связи по пути к целевому ресурсу, предоставляя полезный механизм отладки.

3.4 HTTP ответ
Структура HTTP ответа сервера состоит из:
Строки состояния HTTP ответа, в которой сервер указывает версию HTTP протокола и код состояния.
Нуля или нескольких полей HTTP заголовка, разделенных между собой символом CRLF.
Пустой строки (в этой строке должен быть только символ CRLF), эта строка обозначает окончание полей заголовка.
Необязательное тело HTTP сообщения.
● Status-Code – это целочисленный трехразрядный код результата понимания и удовлетворения запроса клиента.
Грубо говоря, это число, которое показывает то, как сервер понял запрос клиента. К коду состояния HTTP ответа
идет поясняющая фраз, которая предназначена для людей, чтобы те понимали, что в итоге случилось. 
Номер	Код состояния HTTP сервера и его описание
1xx: информационный код состояния HTTP сервера
Все коды состояний, начинающиеся с единицы говорят клиенту о том, что их запрос получен и находится в обработке 
и называются они — информационные коды состояния.
2xx: успешный код состояния HTTP сервера
Все коды состояний, начинающиеся с двойки говорят клиенту о том, что действие закончилось успешно:
получено, понято и обработано, такие коды называются успешные HTTP коды.
3xx: код перенаправления HTTP сервера
Все коды состояния, начинающиеся с тройки говорят клиенту о том, что для продолжения работы ему нужно
совершить какие-то действия, это коды получили название кодов перенаправления HTTP сервера.
4xx: коды ошибок HTTP клиента
Все коды состояния, начинающиеся с четверки говорят нам о том, что ошибка происходит по вине клиента
(неверный синтаксис, устаревший протокол и прочее), из-за чего сервер не может корректно отработать и дать ответ.
Их называют коды ошибок HTTP клиента.
5xx: коды ошибок HTTP сервера
Все коды состояний, начинающиеся с пятерки, говорят нам о том, что произошла ошибка на стороне сервера HTTP.
И они получили называние коды ошибок HTTP сервера.
● Поля заголовка HTTP ответа
Поля заголовка HTTP ответа необходимы серверу для того, чтобы передать дополнительную информацию клиенту,
которая не может быть помещена в строку состояния. Поля заголовка HTTP ответа помогают клиенту правильно
обработать HTTP сообщение сервера. Так же поля заголовка HTTP ответа могут содержать дополнительную
информацию о сервере и о дальнейшем доступе к ресурсу, указанному в URI

4. HTTP объекты
Объекты (HTTP Entity) могут передаваться вместе с сообщением в том случае, если иное не установлено методом
HTTP запроса или кодом состояния HTTP сервера. Структура объекта (HTTP Entity) очень проста:
поля заголовка объекта (HTTP entity-headers);
тело объекта (HTTP entity-body).
Тело HTTP объекта или HTTP entity-body, если оно присутствует в сообщении, имеет свой собственный формат
и способ кодирования (кодирование в HTTP), всё это определяется полями заголовка HTTP entity-header.
Тело объекта (HTTP entity-body) присутствует в сообщении только тогда, когда присутствует тело сообщения.
Тело объекта (HTTP entity-body) получается из тела сообщения путем декодирования передачи.

5. HTTP соединение
HTTP соединение или HTTP Connections на данный момент является постоянным для каждого URL (читай про URI в HTTP),
когда-то давно для каждого запроса клиента использовалось отдельное TCP соединение (даже если страница
просто обновлялась), что создавало большую нагрузку на машины с HTTP серверами, потому что каждый элемент страницы,
например изображение – это один или несколько запросов от клиента к серверу.
Постоянные HTTP соединения (HTTP Connections):
Сейчас не требуется постоянно поднимать новое TCP соединение для запроса, поэтому существенно
экономятся ресурсы серверов.
HTTP запросы клиента и ответы сервера можно представить как непрерывно работающий конвейер, причем параллельный,
в рамках одного TCP соединения.
Для установки TCP соединения машине клиента и машине сервера обязательно нужно посылать пакеты, следовательно,
третий уровень модели OSI был очень загружен, так было до появления постоянного HTTP соединения (HTTP Connections).
Поэтому на данный момент все HTTP клиенты и HTTP серверы разрабатываются с учетом того, чтобы работать,
используя постоянные HTTP соединения между клиентом и сервером. В версии протокола HTTP 1.1 любой клиент
по умолчанию считает, что ему нужно работать с сервером по постоянному HTTP соединению (Persistent Connection HTTP).
Как только клиент и сервер прекратили общаться, им необходимо разорвать TCP соединение,
делается это специальным полем в заголовке Connection
С учетом того, что HTTP соединение постоянное, клиент может посылать несколько HTTP запросов подряд,
не ожидаю HTTP сообщений от сервера, но сервер должен посылать HTTP ответы на сообщения клиента в том порядке,
в котором он получил запросы. С учетом того, что на данный момент используется постоянное
HTTP соединение (HTTP Connections), сервера имеют определенные значения времени ожидания
(конкретные цифры зависят непосредственно от настроек сервера),
после которого они перестают поддерживать неактивные соединения.

6. Аутентификация в HTTP. Проверка подлинности пользователей в HTTP
Аутентификация в HTTP довольно простая: для проверки подлинности используются, как всегда,
HTTP запросы от клиента и HTTP ответы от сервера, но со специальными полями заголовка. 
Для проверки подлинности у HTTP сервера есть специальный механизм, который по-русски называется вызов-ответ,
по-английски: challenge-response. Сервер может применить этот механизм чтобы вызвать (получить) от клиента HTTP
сообщение, в котором будут содержаться данные для аутентификации клиента.
Механизм вызов-ответ по сути – это набор полей HTTP заголовка и, как и любое другое поле, поля установления подлинности
в HTTP имеют атрибуты и значения, одно поле может иметь несколько значений,
которые разделяются запятой и не чувствительны к регистру символов.
Код 401 используется для «активации» механизма аутентификации в HTTP, этим кодом сервер просит клиента предоставить
данные для проверки подлинности HTTP. При этом HTTP ответ сервера должен содержать поле заголовка WWW-Authenticate.
Базовая схема аутентификации в HTTP реализована по принципу: логин-пароль. Клиент высылает серверу логин и пароль
для каждой области, к которой он желает получить доступ. После того, как сервер получил запрос к ресурсу,
указанному в URI, он может ответить клиенту вызовом
Грубо говоря, клиентское приложение отправляет серверу логин и пароль для данной области защиты,
а итоговое поле заголовка после кодирования

7. Механизм обсуждения в HTTP – это процесс, который позволяет выбрать наиболее удобное представление информации для человека.
Протокол HTTP имеет два вида обсуждения: обсуждение, управляемое сервером и обсуждение, управляемое клиентом.
Стоит отметить, что эти два вида обсуждения HTTP независимы друг от друга и могут использоваться вместе.

● Обсуждение, управляемое HTTP сервером
Обсуждение называется управляемым сервером в том случае, когда выбор наилучшего представления информации
для клиента определяется алгоритмами HTTP сервера. Выбор со стороны сервера определяется параметрами,
переданными клиентом: язык, способ кодирования содержимого и прочее, даже IP-адрес клиента может
повлиять на алгоритм сервера, не говоря уже о поле заголовка User-Agent. HTTP обсуждение управляемое
сервером наиболее эффективно, когда у клиента нет никакой информации о ресурсах HTTP сервера.
Клиент может помочь серверу выбрать наиболее удобный вариант при помощи полей заголовков:
Accept, Accept-Language, Accept-Encoding и других, важно, чтобы эти заголовки давали какие-то характеристики контента,
которые хочет получить клиент. Обычно для обсуждения содержимого HTTP сообщения клиента
не используют HTTP метод GET, поскольку он «тянет» с сервера объекты.
Можно привести и недостатки обсуждения, управляемого HTTP сервером:
Сервер никогда не может точно определить по HTTP запросу полные характеристики ответа, которые будут удобны пользователю.
Описывать полные возможности HTTP клиента при каждом запросе – не самое эффективное занятия, к тому же,
не самое безопасное для клиента, ведь протокол HTTP не имеет механизмов шифрования данных,
которое не стоит путать с кодированием содержимого, которое есть в HTTP.
Алгоритм обсуждения содержимого HTTP сервером может сильно его усложнить.
Механизм кэширования тоже усложняется, а иногда и ограничивается.
HTTP сервер при управлении обсуждения должен включать поле заголовка Vary, если ответ кэшируемый.

● Обсуждение, управляемое HTTP клиентом
Если обсуждение управляется HTTP клиентом, то наилучшее представление для пользователя выбирается клиентом.
Такое HTTP обсуждение основывается на полях заголовка, которые сервер отправляет клиенту при первом ответе.
Стоит обратить внимание на то, что HTTP сервер имеет разные URI (URI в HTTP) для разных представлений
одного и того же контента.
HTTP обсуждение, управляемое клиентом очень эффективно, когда ответы сервера изменяются в зависимости
от типичных параметров и характеристик, таких как: человеческий язык или способ кодирования информации. 
Но недостатком HTTP обсуждения, управляемого клиентом, является то, что для получения наиболее удобного
для пользователя контента необходим дополнительный запрос. Версия протокола HTTP 1.1 имеет следующие коды состояния
для управления содержимого на стороне клиента: код 301 (множественный выбор) и код 406 (не приемлем).

● Прозрачное обсуждение HTTP или комбинированное обсуждение
Прозрачное обсуждение HTTP или комбинированное обсуждение заключается в том, что наиболее удобное представление
информации для пользователя определяется сообща. Суть прозрачного обсуждения HTTP в наличии кэша.
По кэшу клиент определяет все доступные представления контента на сервере, но при этом сервер должен
понимать все характеристики, которые ему передает клиент в запросе.