
// Контекст вызова функции This
// This и контекст вызова определяются при вызове функции

// function getThis() {
//     console.log(this);
// }
// getThis();

// использование функции в качестве методов (метод - функция передана как свойство в объекте)

// const prod1 = {
//     name: 'Intel',
//     price: 100,
//     getPrice: function () {
//         console.log(this);
//     },
//     info: {
//         information: ['2.3ghz'],
//         getinfo: function() {
//             console.log(this);
//         },
//     },
// };
// prod1.getPrice; // так как функция была вызвана в контексте объекта, то и в консоле получим объект 
// вызвав функцию в качестве метода объекта, внутри этой функции this будет указывать на этот объект
// this будет равен тому, что находится перед самой крайней точкой
// prod1.info.getinfo();

// Так же функцию можно вынести вне
function getPrice() {
    console.log(this.price);
    return this;
}
function getName () {
    console.log(this.name);
    return this;
}

const prod1 = {
    name: 'Intel',
    price: 100,
    getPrice,
    getName() { // метод для пооучения имени
        console.log(this.name)
    },
    info: {
      information: ['2.3ghz'],
      getinfo: function() {
        console.log(this);
    },
    },
};

prod1.getPrice(); // вызывается все та же функция, с указанием на прайс
prod1.info.getinfo();
const prod2 = {
    name: 'AMD',
    price: 50,
    getPrice,
};
prod2.getPrice(); // вызывается все та же функция, с указанием на прайс, за счет вызова с разным контекстом, функция становится универсальной
prod1.getName();
// Можем передать какие-то функции
prod2.getName = prod1.getName;
prod2.getName();

// Цепочки вызовов методов
// Каждый из этих методов возвращает объект, у которого есть следующий метод
let str = 'Hellow world';
const reverStr = str. 
split(''). // вернет массив по буквам
reverse(). // реверс вернет перевернутый массив
join(''); // снова склеит буквы, которые уже в обратке
// console.log(reverStr);
// Если попытаться вызвать метод, которого нет у результата предыдущего метода, будет ошибка, но это можно реализовать через this

const prod3 = {
    name: 'intel',
    price: 200,
    getPrice,
    getName,
}
prod3. // в функции getprice и getname необходимо заретернить this ([33] ,[37])
getName(). // без return this undefined
getPrice(); // без return this undefined

// Методы call и метод apply, помогают в каком контексте вызывается функция
// Методы apply он отличается тем что аргументы принимает только в качестве массива
// Указываем метод call, который принимает первым агрументом this в контексте которого должна быть вызвана функция
getPrice.call(prod3); // первым должен идти обязательно контекст вызова

// Потеря контекста и вызов функции с определенным контекстом 
// Потеря контекста происходит когда передаем какие-то методы внутрь других функций, которые вызываются в рамках другого контекста
// Метод bind в отличии от call и apply не вызывает функцию, а возвращает эту функцию с привязанным контекстом
const getPriceBind = prod3.getPrice.bind(prod3);
console.log(getPriceBind) 
setTimeout(getPriceBind, 1000); // undefined при prod3.getPrice

// Итог: this указывает на контекст вызова, определяется контекст в момент вызова, в рамках объекта указывает на объект, так же есть возможность
// вызывать методы в цепочке, для этого каждый из методов должен вернуть объект у которого есть следующий метод, который вызывается в этой цепочке,
// так же можем вызывать глобальные функции указывая им контекст при помощи методов call и apply 
// так же можем функциям и методам привязать намертво контекст через Bind 
